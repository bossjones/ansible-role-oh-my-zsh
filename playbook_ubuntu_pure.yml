# USAGE: sudo ansible-playbook --ask-become-pass --check -i "localhost," -c local playbook_ubuntu_pure.yml --extra-vars="bossjones__oh__my__zsh__user=$(whoami) bossjones__oh__my__zsh__theme=powerlevel"
# USAGE: sudo ansible-playbook --ask-become-pass --check -i "localhost," -c local playbook_ubuntu_pure.yml --extra-vars="bossjones__oh__my__zsh__user=$(whoami) bossjones__oh__my__zsh__theme=pure"
---

# # rbenv
# git clone https://github.com/sstephenson/rbenv.git ~/.rbenv
# echo 'export PATH="$HOME/.rbenv/bin:$PATH"' >> ~/.zshrc
# echo 'eval "$(rbenv init -)"' >> ~/.zshrc
# git clone https://github.com/sstephenson/ruby-build.git ~/.rbenv/plugins/ruby-build

# # ruby
# sudo apt-get install -y build-essential bison ruby-dev rake zlib1g-dev \
#     libyaml-dev libssl-dev libreadline-dev libncurses5-dev llvm llvm-dev \
#     libeditline-dev libedit-dev
# rbenv install 2.2.3

- hosts: localhost
  become: yes
  become_method: sudo
  vars:
    bossjones__oh__my__zsh__theme: "pure"
    bossjones__oh__my__zsh__pyenv_version: 2.2.3
    NODE_VERSION_TO_INSTALL: 16.13.1
    rbenv:
      env: personal
      version: v1.1.2
      default_ruby: 2.7.2
      rubies:
        - version: 2.7.2

    bossjones__oh__my__zsh__static_paths_for_proper_install_of_antigen: "$HOME/.rbenv/shims:~/.rbenv/shims:$HOME/.pyenv/plugins/pyenv-virtualenvwrapper/shims:$HOME/.pyenv/libexec:$HOME/.pyenv/plugins/python-build/bin:$HOME/.pyenv/plugins/pyenv-virtualenvwrapper/bin:$HOME/.pyenv/plugins/pyenv-virtualenv/bin:$HOME/.pyenv/plugins/pyenv-update/bin:$HOME/.pyenv/plugins/pyenv-installer/bin:$HOME/.pyenv/plugins/pyenv-doctor/bin:$HOME/.pyenv/bin:$HOME/bin:$HOME/.cargo/bin:/bin:$HOME/.goenv/shims:$HOME/.goenv/bin:~/go/bin:$HOME/.fnm:$HOME/.asdf/shims:$HOME/.asdf/bin:$HOME/.local/bin:~/.pyenv/bin:$HOME/.rbenv/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/usr/games:/usr/local/games:$HOME/.fzf/bin"
    bossjones__oh__my__zsh__goenv_root: "$HOME/.goenv"


    rbenv_clean_up: false

    rbenv_repo: "https://github.com/rbenv/rbenv.git"

    rbenv_plugins:
      - { name: "rbenv-vars",         repo: "https://github.com/rbenv/rbenv-vars.git",         version: "master" }
      - { name: "ruby-build",         repo: "https://github.com/rbenv/ruby-build.git",         version: "master" }
      - { name: "rbenv-default-gems", repo: "https://github.com/rbenv/rbenv-default-gems.git", version: "master" }
      - { name: "rbenv-installer",    repo: "https://github.com/rbenv/rbenv-installer.git",    version: "master" }
      - { name: "rbenv-update",       repo: "https://github.com/rkh/rbenv-update.git",         version: "master" }
      - { name: "rbenv-whatis",       repo: "https://github.com/rkh/rbenv-whatis.git",         version: "master" }
      - { name: "rbenv-use",          repo: "https://github.com/rkh/rbenv-use.git",            version: "master" }

    rbenv_root: "{% if rbenv.env == 'system' %}/usr/local/rbenv{% else %}~/.rbenv{% endif %}"

    rbenv_set_vars: true

    rbenv_users: []

    rbenv_extra_depends:
    - libssl1.0-dev
    - build-essential
    - bison
    - ruby-dev
    - rake
    - zlib1g-dev
    - libyaml-dev
    - libssl-dev
    - libreadline-dev
    - libncurses5-dev
    - llvm
    - llvm-dev
    - libeditline-dev
    - libedit-dev
    rbenv_apt_packages:
    - build-essential
    - curl
    - git
    - libcurl4-openssl-dev
    - libffi-dev
    - libreadline-dev
    - libssl-dev
    - libxml2-dev
    - libxslt1-dev
    - zlib1g-dev
    rbenv_dnf_packages:
    - curl
    - gcc
    - openssl-devel
    - libyaml-devel
    - readline-devel
    - zlib-devel
    - libffi-devel
    - git
    rbenv_yum_packages:
    - bzip2
    - curl
    - gcc
    - git
    - libffi-devel
    - libyaml-devel
    - openssl-devel
    - readline-devel
    - zlib-devel
    rbenv_user_profile: true
    bossjones__oh__my__zsh__enable_zlogin: "yes"
    bossjones__oh__my__zsh__enable_zlogout: "yes"
    bossjones__oh__my__zsh__enable_zprofile: "no"
    bossjones__oh__my__zsh__enable_zshenv: "yes"
    bossjones__oh__my__zsh__install_fzf: "yes"
    bossjones__oh__my__zsh__change_default_shell: yes
    bossjones__oh__my__zsh__path_to_shell: /usr/bin/zsh
    bossjones__oh__my__zsh__antigen_bundles_extras:
      - zdharma-continuum/fast-syntax-highlighting@master
      # Solarized dircolors plugin for zsh
      - joel-porquet/zsh-dircolors-solarized

      # peco/percol/fzf wrapper plugin for zsh
      - mollifier/anyframe

      #  A utility tool powered by fzf for using git interactively.
      - wfxr/forgit

      - { name: eventi/noreallyjustfuckingstopalready, command: killall }
      # https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins
      - { name: vscode, command: code }
      - { name: gpg-agent, command: gpg-agent }
      - history
      # - { name: fd, command: fd }
      # - { name: autopep8, command: autopep8 }
      # - { name: pylint, command: pylint }
      # - { name: ELLIOTTCABLE/rbenv.plugin.zsh, command: ruby }
      # - { name: colored-man-pages, command: man }
      - fd
      - autopep8
      - pylint
      - ELLIOTTCABLE/rbenv.plugin.zsh
      - colored-man-pages

      - { name: bossjones/boss-git-zsh-plugin, command: git }
      - { name: bossjones/boss-docker-zsh-plugin, command: docker }

      # A zsh plugin to sync git repositories and clean them up.
      - caarlos0/zsh-git-sync

      # This ZSH plugin enhances the terminal environment with 256 colors. It looks at the chosen TERM environment variable and sees if there is respective (n-)curses' termcap/terminfo descriptors for 256 colors available. The result is a multicolor terminal, if available.
      - chrissicool/zsh-256color

      # Desktop notifications for long-running commands in zsh.
      - marzocchi/zsh-notify
      # Add zsh's missing hooks, and support for user-defined hooks
      - zsh-hooks/zsh-hooks

      # A collection of git utilities and useful extra git scripts I've discovered or written, packaged for ease of use with shell frameworks.
      - unixorn/git-extra-commands@main

      # alias for docker aliases
      - { name: hadenlabs/zsh-docker@main, command: docker }
      # servers functions for shell
      # - luismayta/zsh-servers-functions
      # Search ssh connect with peco
      # - { name: luismayta/zsh-peco-ssh-connect, command: peco }
      # - luismayta/zsh-peco-ssh-connect

      # Plugin for lazy-loading pyenv in zsh.
      # - { name: erikced/zsh-pyenv-lazy-load, command: pyenv }
      - erikced/zsh-pyenv-lazy-load

      # Convert seconds to a human readable string: 165392 → 1d 21h 56m 32s
      - sindresorhus/pretty-time-zsh@main

      # Because your terminal should be able to perform tasks asynchronously without external tools!
      # - mafredri/zsh-async

      - kiurchv/asdf.plugin.zsh
      # Pretty, minimal and fast ZSH prompt
      - sindresorhus/pure@main

    bossjones__oh__my__zsh__autosuggestions_bind_key: "^U"
    bossjones__oh__my__zsh__path:
      - "{{rbenv_root}}/shims"
      - $HOME/bin
      - $HOME/.local/bin
      - $HOME/.pyenv/bin
      - ~/.pyenv/bin
      - $HOME/.rbenv/bin
      - $HOME/.fnm
      - /usr/local/sbin
      - /usr/local/bin
      - /usr/sbin
      - /usr/bin
      - /sbin
      - /bin
      - /usr/games
      - /usr/local/games

    # SOURCE: https://github.com/sorin-ionescu/prezto/blob/4f19700919c8ebbaf75755fc0d03716d13183f49/runcoms/zshenv
    # #
    # # Defines environment variables.
    # #
    # # Authors:
    # #   Sorin Ionescu <sorin.ionescu@gmail.com>
    # #

    # # Ensure that a non-login, non-interactive shell has a defined environment.
    # if [[ "$SHLVL" -eq 1 && ! -o LOGIN && -s "${ZDOTDIR:-$HOME}/.zprofile" ]]; then
    #   source "${ZDOTDIR:-$HOME}/.zprofile"
    # fi

    bossjones__oh__my__zsh__zshenv: |-
      # Since .zshenv is always sourced, it often contains exported variables that should be available to other programs. For example, $PATH, $EDITOR, and $PAGER are often set in .zshenv. Also, you can set $ZDOTDIR in .zshenv to specify an alternative location for the rest of your zsh configuration.
      # ~/.zshenv: system-wide .zshenv file for zsh(1).
      #
      # This file is sourced on all invocations of the shell.
      # If the -f flag is present or if the NO_RCS option is
      # set within this file, all other initialization files
      # are skipped.
      #
      # This file should contain commands to set the command
      # search path, plus other important environment variables.
      # This file should not contain commands that produce
      # output or assume the shell is attached to a tty.
      #
      # Global Order: zshenv, zprofile, zshrc, zlogin

      export RBENV_ROOT={{rbenv_root}}
      export GOENV_ROOT=$HOME/.goenv

      if [[ -z "$PATH" || "$PATH" == "/bin:/usr/bin" ]]
      then
        export PATH="/usr/local/bin:/usr/bin:/bin:/usr/games"
        export PATH="{{rbenv_root}}/shims:$HOME/bin:$HOME/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:$PATH"
        export PATH="${GOENV_ROOT}/bin:${PATH}"
      fi
      skip_global_compinit=1

    # /usr/local/rbenv/shims:/home/vagrant/bin:/home/vagrant/.local/bin:/home/vagrant/.pyenv/bin:/home/vagrant/.rbenv/bin:/home/vagrant/.fnm:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games

    bossjones__oh__my__zsh__zlogin: |-
      # https://unix.stackexchange.com/questions/71253/what-should-shouldnt-go-in-zshenv-zshrc-zlogin-zprofile-zlogout
      #
      # Executes commands at login post-zshrc.
      #
      # Authors:
      #   Sorin Ionescu <sorin.ionescu@gmail.com>
      #
      # /etc/zsh/zlogin: system-wide .zlogin file for zsh(1).
      #
      # This file is sourced only for login shells. It
      # should contain commands that should be executed only
      # in login shells. It should be used to set the terminal
      # type and run a series of external commands (fortune,
      # msgs, from, etc.)
      #
      # Global Order: zshenv, zprofile, zshrc, zlogin

      source ~/.zshrc


    bossjones__oh__my__zsh__before_scripts:
      - name: fnm.zsh
        content: |-
          export PATH=~/.fnm:$PATH
          # SOURCE: https://github.com/Schniz/fnm
          if [ -n "$(which fnm)" ]; then
              eval "$(fnm env --use-on-cd)"
              if [ "$(fnm ls | grep -i {{NODE_VERSION_TO_INSTALL}} | wc -l)" = "0" ]; then
                fnm install {{NODE_VERSION_TO_INSTALL}} || true
                fnm use {{NODE_VERSION_TO_INSTALL}} || true
                fnm default {{NODE_VERSION_TO_INSTALL}} || true
                fnm current || true
                # npm install -g pure-prompt || true
                # npm install -g pretty-time-zsh || true
              fi
          fi
      - name: asdf.zsh
        content: |-
          if [ -d "$HOME/.asdf" ]; then
            . $HOME/.asdf/asdf.sh
          fi

      - name: kubeconfig.zsh
        content: |-
          if [ -d "/srv/ansible-role-oh-my-zsh" ]; then
            export KUBECONFIG=$KUBECONFIG:/srv/ansible-role-oh-my-zsh/kube-config
          fi

          enable_kubectl_completion() {
            if [ -n "$(which kubectl)" ]; then
              source <(kubectl completion zsh)
            fi
          }

      - name: rust.zsh
        content: |-
          if [ -d "$HOME/.cargo/bin" ]; then
            export PATH=$HOME/.cargo/bin:$PATH
          fi
      - name: notify.zsh
        content: |-
          # https://github.com/marzocchi/zsh-notify
          # Enable when connected over SSH, which is disabled by default.
          zstyle ':notify:*' enable-on-ssh yes
      - name: async.zsh
        content: |-
          # SOURCE: https://github.com/mafredri/zsh-async/blob/master/async.zsh

          #
          # zsh-async
          #
          # version: v1.8.5
          # author: Mathias Fredriksson
          # url: https://github.com/mafredri/zsh-async
          #

          typeset -g ASYNC_VERSION=1.8.5
          # Produce debug output from zsh-async when set to 1.
          typeset -g ASYNC_DEBUG=${ASYNC_DEBUG:-0}

          # Execute commands that can manipulate the environment inside the async worker. Return output via callback.
          _async_eval() {
            local ASYNC_JOB_NAME
            # Rename job to _async_eval and redirect all eval output to cat running
            # in _async_job. Here, stdout and stderr are not separated for
            # simplicity, this could be improved in the future.
            {
              eval "$@"
            } &> >(ASYNC_JOB_NAME=[async/eval] _async_job 'command -p cat')
          }

          # Wrapper for jobs executed by the async worker, gives output in parseable format with execution time
          _async_job() {
            # Disable xtrace as it would mangle the output.
            setopt localoptions noxtrace

            # Store start time for job.
            float -F duration=$EPOCHREALTIME

            # Run the command and capture both stdout (`eval`) and stderr (`cat`) in
            # separate subshells. When the command is complete, we grab write lock
            # (mutex token) and output everything except stderr inside the command
            # block, after the command block has completed, the stdin for `cat` is
            # closed, causing stderr to be appended with a $'\0' at the end to mark the
            # end of output from this job.
            local jobname=${ASYNC_JOB_NAME:-$1} out
            out="$(
              local stdout stderr ret tok
              {
                stdout=$(eval "$@")
                ret=$?
                duration=$(( EPOCHREALTIME - duration ))  # Calculate duration.

                print -r -n - $'\0'${(q)jobname} $ret ${(q)stdout} $duration
              } 2> >(stderr=$(command -p cat) && print -r -n - " "${(q)stderr}$'\0')
            )"
            if [[ $out != $'\0'*$'\0' ]]; then
              # Corrupted output (aborted job?), skipping.
              return
            fi

            # Grab mutex lock, stalls until token is available.
            read -r -k 1 -p tok || return 1

            # Return output (<job_name> <return_code> <stdout> <duration> <stderr>).
            print -r -n - "$out"

            # Unlock mutex by inserting a token.
            print -n -p $tok
          }

          # The background worker manages all tasks and runs them without interfering with other processes
          _async_worker() {
            # Reset all options to defaults inside async worker.
            emulate -R zsh

            # Make sure monitor is unset to avoid printing the
            # pids of child processes.
            unsetopt monitor

            # Redirect stderr to `/dev/null` in case unforseen errors produced by the
            # worker. For example: `fork failed: resource temporarily unavailable`.
            # Some older versions of zsh might also print malloc errors (know to happen
            # on at least zsh 5.0.2 and 5.0.8) likely due to kill signals.
            exec 2>/dev/null

            # When a zpty is deleted (using -d) all the zpty instances created before
            # the one being deleted receive a SIGHUP, unless we catch it, the async
            # worker would simply exit (stop working) even though visible in the list
            # of zpty's (zpty -L). This has been fixed around the time of Zsh 5.4
            # (not released).
            if ! is-at-least 5.4.1; then
              TRAPHUP() {
                return 0  # Return 0, indicating signal was handled.
              }
            fi

            local -A storage
            local unique=0
            local notify_parent=0
            local parent_pid=0
            local coproc_pid=0
            local processing=0

            local -a zsh_hooks zsh_hook_functions
            zsh_hooks=(chpwd periodic precmd preexec zshexit zshaddhistory)
            zsh_hook_functions=(${^zsh_hooks}_functions)
            unfunction $zsh_hooks &>/dev/null   # Deactivate all zsh hooks inside the worker.
            unset $zsh_hook_functions           # And hooks with registered functions.
            unset zsh_hooks zsh_hook_functions  # Cleanup.

            close_idle_coproc() {
              local -a pids
              pids=(${${(v)jobstates##*:*:}%\=*})

              # If coproc (cat) is the only child running, we close it to avoid
              # leaving it running indefinitely and cluttering the process tree.
              if  (( ! processing )) && [[ $#pids = 1 ]] && [[ $coproc_pid = $pids[1] ]]; then
                coproc :
                coproc_pid=0
              fi
            }

            child_exit() {
              close_idle_coproc

              # On older version of zsh (pre 5.2) we notify the parent through a
              # SIGWINCH signal because `zpty` did not return a file descriptor (fd)
              # prior to that.
              if (( notify_parent )); then
                # We use SIGWINCH for compatibility with older versions of zsh
                # (pre 5.1.1) where other signals (INFO, ALRM, USR1, etc.) could
                # cause a deadlock in the shell under certain circumstances.
                kill -WINCH $parent_pid
              fi
            }

            # Register a SIGCHLD trap to handle the completion of child processes.
            trap child_exit CHLD

            # Process option parameters passed to worker.
            while getopts "np:uz" opt; do
              case $opt in
                n) notify_parent=1;;
                p) parent_pid=$OPTARG;;
                u) unique=1;;
                z) notify_parent=0;;  # Uses ZLE watcher instead.
              esac
            done

            # Terminate all running jobs, note that this function does not
            # reinstall the child trap.
            terminate_jobs() {
              trap - CHLD   # Ignore child exits during kill.
              coproc :      # Quit coproc.
              coproc_pid=0  # Reset pid.

              if is-at-least 5.4.1; then
                trap '' HUP    # Catch the HUP sent to this process.
                kill -HUP -$$  # Send to entire process group.
                trap - HUP     # Disable HUP trap.
              else
                # We already handle HUP for Zsh < 5.4.1.
                kill -HUP -$$  # Send to entire process group.
              fi
            }

            killjobs() {
              local tok
              local -a pids
              pids=(${${(v)jobstates##*:*:}%\=*})

              # No need to send SIGHUP if no jobs are running.
              (( $#pids == 0 )) && continue
              (( $#pids == 1 )) && [[ $coproc_pid = $pids[1] ]] && continue

              # Grab lock to prevent half-written output in case a child
              # process is in the middle of writing to stdin during kill.
              (( coproc_pid )) && read -r -k 1 -p tok

              terminate_jobs
              trap child_exit CHLD  # Reinstall child trap.
            }

            local request do_eval=0
            local -a cmd
            while :; do
              # Wait for jobs sent by async_job.
              read -r -d $'\0' request || {
                # Unknown error occurred while reading from stdin, the zpty
                # worker is likely in a broken state, so we shut down.
                terminate_jobs

                # Stdin is broken and in case this was an unintended
                # crash, we try to report it as a last hurrah.
                print -r -n $'\0'"'[async]'" $(( 127 + 3 )) "''" 0 "'$0:$LINENO: zpty fd died, exiting'"$'\0'

                # We use `return` to abort here because using `exit` may
                # result in an infinite loop that never exits and, as a
                # result, high CPU utilization.
                return $(( 127 + 1 ))
              }

              # We need to clean the input here because sometimes when a zpty
              # has died and been respawned, messages will be prefixed with a
              # carraige return (\r, or \C-M).
              request=${request#$'\C-M'}

              # Check for non-job commands sent to worker
              case $request in
                _killjobs)    killjobs; continue;;
                _async_eval*) do_eval=1;;
              esac

              # Parse the request using shell parsing (z) to allow commands
              # to be parsed from single strings and multi-args alike.
              cmd=("${(z)request}")

              # Name of the job (first argument).
              local job=$cmd[1]

              # Check if a worker should perform unique jobs, unless
              # this is an eval since they run synchronously.
              if (( !do_eval )) && (( unique )); then
                # Check if a previous job is still running, if yes,
                # skip this job and let the previous one finish.
                for pid in ${${(v)jobstates##*:*:}%\=*}; do
                  if [[ ${storage[$job]} == $pid ]]; then
                    continue 2
                  fi
                done
              fi

              # Guard against closing coproc from trap before command has started.
              processing=1

              # Because we close the coproc after the last job has completed, we must
              # recreate it when there are no other jobs running.
              if (( ! coproc_pid )); then
                # Use coproc as a mutex for synchronized output between children.
                coproc command -p cat
                coproc_pid="$!"
                # Insert token into coproc
                print -n -p "t"
              fi

              if (( do_eval )); then
                shift cmd  # Strip _async_eval from cmd.
                _async_eval $cmd
              else
                # Run job in background, completed jobs are printed to stdout.
                _async_job $cmd &
                # Store pid because zsh job manager is extremely unflexible (show jobname as non-unique '$job')...
                storage[$job]="$!"
              fi

              processing=0  # Disable guard.

              if (( do_eval )); then
                do_eval=0

                # When there are no active jobs we can't rely on the CHLD trap to
                # manage the coproc lifetime.
                close_idle_coproc
              fi
            done
          }

          #
          # Get results from finished jobs and pass it to the to callback function. This is the only way to reliably return the
          # job name, return code, output and execution time and with minimal effort.
          #
          # If the async process buffer becomes corrupt, the callback will be invoked with the first argument being `[async]` (job
          # name), non-zero return code and fifth argument describing the error (stderr).
          #
          # usage:
          # 	async_process_results <worker_name> <callback_function>
          #
          # callback_function is called with the following parameters:
          # 	$1 = job name, e.g. the function passed to async_job
          # 	$2 = return code
          # 	$3 = resulting stdout from execution
          # 	$4 = execution time, floating point e.g. 2.05 seconds
          # 	$5 = resulting stderr from execution
          #	$6 = has next result in buffer (0 = buffer empty, 1 = yes)
          #
          async_process_results() {
            setopt localoptions unset noshwordsplit noksharrays noposixidentifiers noposixstrings

            local worker=$1
            local callback=$2
            local caller=$3
            local -a items
            local null=$'\0' data
            integer -l len pos num_processed has_next

            typeset -gA ASYNC_PROCESS_BUFFER

            # Read output from zpty and parse it if available.
            while zpty -r -t $worker data 2>/dev/null; do
              ASYNC_PROCESS_BUFFER[$worker]+=$data
              len=${#ASYNC_PROCESS_BUFFER[$worker]}
              pos=${ASYNC_PROCESS_BUFFER[$worker][(i)$null]}  # Get index of NULL-character (delimiter).

              # Keep going until we find a NULL-character.
              if (( ! len )) || (( pos > len )); then
                continue
              fi

              while (( pos <= len )); do
                # Take the content from the beginning, until the NULL-character and
                # perform shell parsing (z) and unquoting (Q) as an array (@).
                items=("${(@Q)${(z)ASYNC_PROCESS_BUFFER[$worker][1,$pos-1]}}")

                # Remove the extracted items from the buffer.
                ASYNC_PROCESS_BUFFER[$worker]=${ASYNC_PROCESS_BUFFER[$worker][$pos+1,$len]}

                len=${#ASYNC_PROCESS_BUFFER[$worker]}
                if (( len > 1 )); then
                  pos=${ASYNC_PROCESS_BUFFER[$worker][(i)$null]}  # Get index of NULL-character (delimiter).
                fi

                has_next=$(( len != 0 ))
                if (( $#items == 5 )); then
                  items+=($has_next)
                  $callback "${(@)items}"  # Send all parsed items to the callback.
                  (( num_processed++ ))
                elif [[ -z $items ]]; then
                  # Empty items occur between results due to double-null ($'\0\0')
                  # caused by commands being both pre and suffixed with null.
                else
                  # In case of corrupt data, invoke callback with *async* as job
                  # name, non-zero exit status and an error message on stderr.
                  $callback "[async]" 1 "" 0 "$0:$LINENO: error: bad format, got ${#items} items (${(q)items})" $has_next
                fi
              done
            done

            (( num_processed )) && return 0

            # Avoid printing exit value when `setopt printexitvalue` is active.`
            [[ $caller = trap || $caller = watcher ]] && return 0

            # No results were processed
            return 1
          }

          # Watch worker for output
          _async_zle_watcher() {
            setopt localoptions noshwordsplit
            typeset -gA ASYNC_PTYS ASYNC_CALLBACKS
            local worker=$ASYNC_PTYS[$1]
            local callback=$ASYNC_CALLBACKS[$worker]

            if [[ -n $2 ]]; then
              # from man zshzle(1):
              # `hup' for a disconnect, `nval' for a closed or otherwise
              # invalid descriptor, or `err' for any other condition.
              # Systems that support only the `select' system call always use
              # `err'.

              # this has the side effect to unregister the broken file descriptor
              async_stop_worker $worker

              if [[ -n $callback ]]; then
                $callback '[async]' 2 "" 0 "$0:$LINENO: error: fd for $worker failed: zle -F $1 returned error $2" 0
              fi
              return
            fi;

            if [[ -n $callback ]]; then
              async_process_results $worker $callback watcher
            fi
          }

          _async_send_job() {
            setopt localoptions noshwordsplit noksharrays noposixidentifiers noposixstrings

            local caller=$1
            local worker=$2
            shift 2

            zpty -t $worker &>/dev/null || {
              typeset -gA ASYNC_CALLBACKS
              local callback=$ASYNC_CALLBACKS[$worker]

              if [[ -n $callback ]]; then
                $callback '[async]' 3 "" 0 "$0:$LINENO: error: no such worker: $worker" 0
              else
                print -u2 "$caller: no such async worker: $worker"
              fi
              return 1
            }

            zpty -w $worker "$@"$'\0'
          }

          #
          # Start a new asynchronous job on specified worker, assumes the worker is running.
          #
          # Note if you are using a function for the job, it must have been defined before the worker was
          # started or you will get a `command not found` error.
          #
          # usage:
          # 	async_job <worker_name> <my_function> [<function_params>]
          #
          async_job() {
            setopt localoptions noshwordsplit noksharrays noposixidentifiers noposixstrings

            local worker=$1; shift

            local -a cmd
            cmd=("$@")
            if (( $#cmd > 1 )); then
              cmd=(${(q)cmd})  # Quote special characters in multi argument commands.
            fi

            _async_send_job $0 $worker "$cmd"
          }

          #
          # Evaluate a command (like async_job) inside the async worker, then worker environment can be manipulated. For example,
          # issuing a cd command will change the PWD of the worker which will then be inherited by all future async jobs.
          #
          # Output will be returned via callback, job name will be [async/eval].
          #
          # usage:
          # 	async_worker_eval <worker_name> <my_function> [<function_params>]
          #
          async_worker_eval() {
            setopt localoptions noshwordsplit noksharrays noposixidentifiers noposixstrings

            local worker=$1; shift

            local -a cmd
            cmd=("$@")
            if (( $#cmd > 1 )); then
              cmd=(${(q)cmd})  # Quote special characters in multi argument commands.
            fi

            # Quote the cmd in case RC_EXPAND_PARAM is set.
            _async_send_job $0 $worker "_async_eval $cmd"
          }

          # This function traps notification signals and calls all registered callbacks
          _async_notify_trap() {
            setopt localoptions noshwordsplit

            local k
            for k in ${(k)ASYNC_CALLBACKS}; do
              async_process_results $k ${ASYNC_CALLBACKS[$k]} trap
            done
          }

          #
          # Register a callback for completed jobs. As soon as a job is finnished, async_process_results will be called with the
          # specified callback function. This requires that a worker is initialized with the -n (notify) option.
          #
          # usage:
          # 	async_register_callback <worker_name> <callback_function>
          #
          async_register_callback() {
            setopt localoptions noshwordsplit nolocaltraps

            typeset -gA ASYNC_PTYS ASYNC_CALLBACKS
            local worker=$1; shift

            ASYNC_CALLBACKS[$worker]="$*"

            # Enable trap when the ZLE watcher is unavailable, allows
            # workers to notify (via -n) when a job is done.
            if [[ ! -o interactive ]] || [[ ! -o zle ]]; then
              trap '_async_notify_trap' WINCH
            elif [[ -o interactive ]] && [[ -o zle ]]; then
              local fd w
              for fd w in ${(@kv)ASYNC_PTYS}; do
                if [[ $w == $worker ]]; then
                  zle -F $fd _async_zle_watcher  # Register the ZLE handler.
                  break
                fi
              done
            fi
          }

          #
          # Unregister the callback for a specific worker.
          #
          # usage:
          # 	async_unregister_callback <worker_name>
          #
          async_unregister_callback() {
            typeset -gA ASYNC_CALLBACKS

            unset "ASYNC_CALLBACKS[$1]"
          }

          #
          # Flush all current jobs running on a worker. This will terminate any and all running processes under the worker, use
          # with caution.
          #
          # usage:
          # 	async_flush_jobs <worker_name>
          #
          async_flush_jobs() {
            setopt localoptions noshwordsplit

            local worker=$1; shift

            # Check if the worker exists
            zpty -t $worker &>/dev/null || return 1

            # Send kill command to worker
            async_job $worker "_killjobs"

            # Clear the zpty buffer.
            local junk
            if zpty -r -t $worker junk '*'; then
              (( ASYNC_DEBUG )) && print -n "async_flush_jobs $worker: ${(V)junk}"
              while zpty -r -t $worker junk '*'; do
                (( ASYNC_DEBUG )) && print -n "${(V)junk}"
              done
              (( ASYNC_DEBUG )) && print
            fi

            # Finally, clear the process buffer in case of partially parsed responses.
            typeset -gA ASYNC_PROCESS_BUFFER
            unset "ASYNC_PROCESS_BUFFER[$worker]"
          }

          #
          # Start a new async worker with optional parameters, a worker can be told to only run unique tasks and to notify a
          # process when tasks are complete.
          #
          # usage:
          # 	async_start_worker <worker_name> [-u] [-n] [-p <pid>]
          #
          # opts:
          # 	-u unique (only unique job names can run)
          # 	-n notify through SIGWINCH signal
          # 	-p pid to notify (defaults to current pid)
          #
          async_start_worker() {
            setopt localoptions noshwordsplit noclobber

            local worker=$1; shift
            local -a args
            args=("$@")
            zpty -t $worker &>/dev/null && return

            typeset -gA ASYNC_PTYS
            typeset -h REPLY
            typeset has_xtrace=0

            if [[ -o interactive ]] && [[ -o zle ]]; then
              # Inform the worker to ignore the notify flag and that we're
              # using a ZLE watcher instead.
              args+=(-z)

              if (( ! ASYNC_ZPTY_RETURNS_FD )); then
                # When zpty doesn't return a file descriptor (on older versions of zsh)
                # we try to guess it anyway.
                integer -l zptyfd
                exec {zptyfd}>&1  # Open a new file descriptor (above 10).
                exec {zptyfd}>&-  # Close it so it's free to be used by zpty.
              fi
            fi

            # Workaround for stderr in the main shell sometimes (incorrectly) being
            # reassigned to /dev/null by the reassignment done inside the async
            # worker.
            # See https://github.com/mafredri/zsh-async/issues/35.
            integer errfd=-1

            # Redirect of errfd is broken on zsh 5.0.2.
            if is-at-least 5.0.8; then
              exec {errfd}>&2
            fi

            # Make sure async worker is started without xtrace
            # (the trace output interferes with the worker).
            [[ -o xtrace ]] && {
              has_xtrace=1
              unsetopt xtrace
            }

            if (( errfd != -1 )); then
              zpty -b $worker _async_worker -p $$ $args 2>&$errfd
            else
              zpty -b $worker _async_worker -p $$ $args
            fi
            local ret=$?

            # Re-enable it if it was enabled, for debugging.
            (( has_xtrace )) && setopt xtrace
            (( errfd != -1 )) && exec {errfd}>& -

            if (( ret )); then
              async_stop_worker $worker
              return 1
            fi

            if ! is-at-least 5.0.8; then
              # For ZSH versions older than 5.0.8 we delay a bit to give
              # time for the worker to start before issuing commands,
              # otherwise it will not be ready to receive them.
              sleep 0.001
            fi

            if [[ -o interactive ]] && [[ -o zle ]]; then
              if (( ! ASYNC_ZPTY_RETURNS_FD )); then
                REPLY=$zptyfd  # Use the guessed value for the file desciptor.
              fi

              ASYNC_PTYS[$REPLY]=$worker  # Map the file desciptor to the worker.
            fi
          }

          #
          # Stop one or multiple workers that are running, all unfetched and incomplete work will be lost.
          #
          # usage:
          # 	async_stop_worker <worker_name_1> [<worker_name_2>]
          #
          async_stop_worker() {
            setopt localoptions noshwordsplit

            local ret=0 worker k v
            for worker in $@; do
              # Find and unregister the zle handler for the worker
              for k v in ${(@kv)ASYNC_PTYS}; do
                if [[ $v == $worker ]]; then
                  zle -F $k
                  unset "ASYNC_PTYS[$k]"
                fi
              done
              async_unregister_callback $worker
              zpty -d $worker 2>/dev/null || ret=$?

              # Clear any partial buffers.
              typeset -gA ASYNC_PROCESS_BUFFER
              unset "ASYNC_PROCESS_BUFFER[$worker]"
            done

            return $ret
          }

          #
          # Initialize the required modules for zsh-async. To be called before using the zsh-async library.
          #
          # usage:
          # 	async_init
          #
          async_init() {
            (( ASYNC_INIT_DONE )) && return
            typeset -g ASYNC_INIT_DONE=1

            zmodload zsh/zpty
            zmodload zsh/datetime

            # Load is-at-least for reliable version check.
            autoload -Uz is-at-least

            # Check if zsh/zpty returns a file descriptor or not,
            # shell must also be interactive with zle enabled.
            typeset -g ASYNC_ZPTY_RETURNS_FD=0
            [[ -o interactive ]] && [[ -o zle ]] && {
              typeset -h REPLY
              zpty _async_test :
              (( REPLY )) && ASYNC_ZPTY_RETURNS_FD=1
              zpty -d _async_test
            }
          }

          async() {
            async_init
          }

          async "$@"
      - name: go.zsh
        content: |-
          if [ -d "/usr/local/go/bin" ]; then
            export PATH=/usr/local/go/bin:$PATH
          fi
          export PATH=$GOPATH/bin:$PATH
          alias cdgo='CDPATH=.:$GOPATH/src/github.com:$GOPATH/src/golang.org:$GOPATH/src'

          if [ -d ~/.goenv ]; then
            export GOENV_ROOT="$HOME/.goenv"
            export PATH="$GOENV_ROOT/bin:$PATH"
            eval "$(goenv init -)"
            export PATH="$GOROOT/bin:$PATH"
            export PATH="$PATH:$GOPATH/bin"
          fi

      - name: workon.zsh
        content: |-
          export WORKON_HOME="$HOME/.pyenv/versions"
          export PROJECT_HOME=$HOME/dev

      - name: fzf.zsh
        content: |-
          [ -f ~/.fzf.zsh ] && . ~/.fzf.zsh

      - name: pure.zsh
        content: |-
          if [ -d "$HOME/.zsh/pure" ]; then
            fpath+=$HOME/.zsh/pure
          fi
      - name: pure.zsh
        content: |-
          if [ -d "$HOME/.zsh/pure" ]; then
            fpath+=$HOME/.zsh/pure
          fi

      - name: poetry.zsh
        content: |-
          if [ -d "$HOME/.asdf/installs/poetry/1.0.10/env" ]; then
            . $HOME/.asdf/installs/poetry/1.0.10/env
          fi

    bossjones__oh__my__zsh__after_scripts:
      - name: fnm.zsh
        content: |-
          # SOURCE: https://github.com/Schniz/fnm
          if [ -n "$(which fnm)" ]; then
              eval "$(fnm env --use-on-cd)"
              if [ "$(fnm ls | grep -i {{NODE_VERSION_TO_INSTALL}} | wc -l)" = "0" ]; then
                fnm install {{NODE_VERSION_TO_INSTALL}} || true
                fnm use {{NODE_VERSION_TO_INSTALL}} || true
                fnm default {{NODE_VERSION_TO_INSTALL}} || true
                fnm current || true
                npm install -g pure-prompt || true
                npm install -g pretty-time-zsh || true
              fi
          fi

      - name: gnubin.zsh
        content: |-
          alias ls="ls --color=always"

      - name: fzf.zsh
        content: |
          [ -f ~/.fzf.zsh ] && . ~/.fzf.zsh

      - name: glob.zsh
        content: |
          # see `man zshoptions`
          setopt EXTENDED_GLOB

      - name: history.zsh
        content: |
          # # see `man zshoptions`
          # # SOURCE: https://linux.die.net/man/1/zshoptions
          # # SOURCE: http://zsh.sourceforge.net/Doc/Release/Options.html
          # # Save each command's beginning timestamp (in seconds since the epoch) and the duration (in seconds) to the history file. The format of this prefixed data is:
          # # ':<beginning time>:<elapsed seconds>:<command>'.
          # setopt EXTENDED_HISTORY

          # # If a new command line being added to the history list duplicates an older one, the older command is removed from the list (even if it is not the previous event).
          # setopt HIST_IGNORE_ALL_DUPS

          # # APPEND_HISTORY <D>
          # # If this is set, zsh sessions will append their history list to the history file, rather than replace it. Thus, multiple parallel zsh sessions will all have the new entries from their history lists added to the history file, in the order that they exit. The file will still be periodically re-written to trim it when the number of lines grows 20% beyond the value specified by $SAVEHIST (see also the HIST_SAVE_BY_COPY option).
          # # --------------------------------------------------
          # # This options works like APPEND_HISTORY except that new history lines are added to the $HISTFILE incrementally (as soon as they are entered), rather than waiting until the shell exits. The file will still be periodically re-written to trim it when the number of lines grows 20% beyond the value specified by $SAVEHIST (see also the HIST_SAVE_BY_COPY option).
          # setopt INC_APPEND_HISTORY

          # setopt INC_APPEND_HISTORY_TIME
          # setopt SHARE_HISTORY

          # SOURCE: https://github.com/balakrishnanc/dotfiles/blob/bff74304808b68ffbc571b2d13d3b8077ce65c4e/zsh/zshenv.template
          # Remove superfluous blanks from each command line being added
          #  to the history list.
          setopt HIST_REDUCE_BLANKS

          # When writing out the history file, older commands that duplicate newer ones
          #  are omitted.
          setopt HIST_SAVE_NO_DUPS

          # If you find that you want more control over when commands get imported,
          #  you may wish to turn SHARE_HISTORY off,
          #  INC_APPEND_HISTORY or INC_APPEND_HISTORY_TIME on, and then manually import
          #  commands whenever you need them using 'fc -RI'.
          unsetopt SHARE_HISTORY

          # This option is a variant of INC_APPEND_HISTORY in which, where possible,
          #  the history entry is written out to the file after the command is finished,
          #  so that the time taken by the command is recorded correctly in the
          #  history file in EXTENDED_HISTORY format. This means that the history entry
          #  will not be available immediately from other instances of the shell that are
          #  using the same history file.
          # This option is only useful if INC_APPEND_HISTORY and SHARE_HISTORY are
          #  turned off. The three options should be considered mutually exclusive.
          setopt INC_APPEND_HISTORY_TIME

          # This options works like APPEND_HISTORY except that new history lines are
          #  added to the $HISTFILE incrementally (as soon as they are entered),
          #  rather than waiting until the shell exits.
          unsetopt INC_APPEND_HISTORY

      - name: yq.zsh
        content: |-
          if [ -e "${HOME}/.asdf/shims/yq" ]; then
              yq shell-completion zsh > "${fpath[1]}/_yq"
          fi

          if [ -e /usr/local/bin/yq ]; then
              yq shell-completion zsh > "${fpath[1]}/_yq"
          fi

      - name: rbenv.zsh
        content: |
          if [ -e {{rbenv_root}} ]; then
            export PATH="{{rbenv_root}}/shims:$PATH"
          fi
          if [[ -x $(which rbenv) ]]; then
            eval "$(rbenv init -)"
          fi

      - name: path.zsh
        content: |
          if [ -d "$HOME/bin" ]; then
            export PATH=$HOME/bin:$PATH
          fi
      # - name: cheat.zsh
      #   content: |
      #     if [ -d "$HOME/bin" ]; then
      #       export PATH=$HOME/bin:$PATH
      #     fi

      - name: pyenv.zsh
        content: |
          if [ -e ~/.pyenv ]; then
            export PYENV_ROOT=~/.pyenv
            export PATH="$PYENV_ROOT/bin:$PATH"
            eval "$(pyenv init -)"
            pyenv virtualenvwrapper_lazy
          fi

      - name: updatedb.zsh
        content: |
          # updatedb () {

          #     sudo /usr/libexec/locate.updatedb

          # }
      - name: custom_plugins.zsh
        content: |
          plugins+=(git-extra-commands zsh-256color zsh-peco-history)


      - name: unixorn.zsh
        content: |
          # SOURCE: https://github.com/unixorn/zsh-quickstart-kit/blob/master/zsh/.zsh_aliases
          # aliases borrowed from unixorn
          alias historysummary="history | awk '{a[\$2]++} END{for(i in a){printf \"%5d\t%s\n\",a[i],i}}' | sort -rn | head"

          # A couple of different external IP lookups depending on which is down.
          alias external_ip="curl -s icanhazip.com"
          alias myip="dig +short myip.opendns.com @resolver1.opendns.com"

          # Show laptop's IP addresses
          alias ips="ifconfig -a | perl -nle'/(\d+\.\d+\.\d+\.\d+)/ && print $1'"

          # SSH stuff
          # Pass our credentials by default
          alias sshA='ssh -A'
          alias ssh-A='ssh -A'
          alias ssh-unkeyed='/usr/bin/ssh'
          alias ssh_unkeyed='/usr/bin/ssh'

          alias scp-no-hostchecks='scp -o UserKnownHostsFile=/dev/null -o GlobalKnownHostsFile=/dev/null -o StrictHostKeyChecking=no'
          alias ssh-no-hostchecks='ssh -A -o UserKnownHostsFile=/dev/null -o GlobalKnownHostsFile=/dev/null -o StrictHostKeyChecking=no'
          alias scp_no_hostchecks='scp -o UserKnownHostsFile=/dev/null -o GlobalKnownHostsFile=/dev/null -o StrictHostKeyChecking=no'
          alias ssh_no_hostchecks='ssh -A -o UserKnownHostsFile=/dev/null -o GlobalKnownHostsFile=/dev/null -o StrictHostKeyChecking=no'

          # Set up even more shortcuts because I am that lazy a typist.
          alias nh-scp=scp-no-hostchecks
          alias nh-ssh=ssh-no-hostchecks
          alias nh_scp=scp-no-hostchecks
          alias nh_ssh=ssh-no-hostchecks
          alias nhscp=scp-no-hostchecks
          alias nhssh=ssh-no-hostchecks

          # Strip color codes from commands that insist on spewing them so we can
          # pipe them into files cleanly.
          alias stripcolors='sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[mGK]//g"'

          # lists zombie processes
          zombie() {
            ps aux | awk '{if ($8=="Z") { print $2 }}'
          }
          alias zombies=zombie

    bossjones__oh__my__zsh__zshrc_local: |-
      export SHELL="{{bossjones__oh__my__zsh__path_to_shell}}"
      export RBENV_ROOT={{rbenv_root}}
      export RBENV_VERSION={{rbenv.default_ruby}}
      export VIRTUAL_ENV_DISABLE_PROMPT=1
      export ZSH_PYENV_LAZY_VIRTUALENV=1
      # Larger bash history (allow 32³ entries; default is 500)

      # set some history options
      setopt append_history
      setopt extended_history
      setopt hist_expire_dups_first
      setopt hist_ignore_all_dups
      setopt hist_ignore_dups
      setopt hist_ignore_space
      setopt hist_reduce_blanks
      setopt hist_save_no_dups
      setopt hist_verify
      setopt INC_APPEND_HISTORY
      unsetopt HIST_BEEP

      # Share your history across all your terminal windows
      setopt share_history
      #setopt noclobber

      # Larger bash history (allow 32³ entries; default is 500)

      HISTSIZE=100000
      SAVEHIST=100000
      HISTFILE="$HOME/.zsh_history"
      # export HISTCONTROL=ignoredups

      # # Prefer US English and use UTF-8
      # export LANG=en_US.UTF-8
      # export LC_ALL=en_US.UTF-8

      # # SOURCE: https://github.com/luismayta/dotfiles/blob/597ddc09e1bfccc43076ca21cb679299b83912e4/conf/shell/zshrc
      # # don't put duplicate lines in the history. See bash(1) for more options
      # # ... or force ignoredups and ignorespace
      # HISTCONTROL=ignoredups:ignorespace

      # # for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
      # HISTSIZE=100000
      # HISTFILESIZE=2000

      alias reload!='exec "$SHELL" -l'

      fixprompt() {
        antigen reset; reload!
      }

      # setopt HIST_FIND_NO_DUPS

      # Add some completions settings
      setopt ALWAYS_TO_END     # Move cursor to the end of a completed word.
      setopt AUTO_LIST         # Automatically list choices on ambiguous completion.
      setopt AUTO_MENU         # Show completion menu on a successive tab press.
      setopt AUTO_PARAM_SLASH  # If completed parameter is a directory, add a trailing slash.
      setopt COMPLETE_IN_WORD  # Complete from both ends of a word.
      unsetopt MENU_COMPLETE   # Do not autoselect the first completion entry.

      # Long running processes should return time after they complete. Specified
      # in seconds.
      REPORTTIME=2
      TIMEFMT="%U user %S system %P cpu %*Es total"

      # # Speed up autocomplete, force prefix mapping
      # zstyle ':completion:*' accept-exact '*(N)'
      # zstyle ':completion:*' use-cache on
      # zstyle ':completion:*' cache-path ~/.zsh/cache
      # zstyle -e ':completion:*:default' list-colors 'reply=("${PREFIX:+=(#bi)($PREFIX:t)*==34=34}:${(s.:.)LS_COLORS}")';


      if [ -n "$(which direnv)" ]; then
          eval "$(direnv hook zsh)"
      fi

      [ -f ~/.fzf.zsh ] && source ~/.fzf.zsh

      if [ -n "$(which kubectl)" ]; then
        source <(kubectl completion zsh); echo "kubectl autocomplete loaded"
      fi


      # remove dupes from $PATH using a zsh builtin
      # https://til.hashrocket.com/posts/7evpdebn7g-remove-duplicates-in-zsh-path
      typeset -aU path;

      # # Load iTerm shell integrations if found.
      # test -e "${HOME}/.iterm2_shell_integration.zsh" && source "${HOME}/.iterm2_shell_integration.zsh"

      # Expand aliases inline - see http://blog.patshead.com/2012/11/automatically-expaning-zsh-global-aliases---simplified.html
      globalias() {
         if [[ $LBUFFER =~ ' [A-Z0-9]+$' ]]; then
           zle _expand_alias
           zle expand-word
         fi
         zle self-insert
      }

      zle -N globalias

      bindkey " " globalias
      bindkey "^ " magic-space           # control-space to bypass completion
      bindkey -M isearch " " magic-space # normal space during searches


  roles:
    - ../ansible-role-oh-my-zsh

  # tasks:

  #   # SOURCE: https://github.com/veggiemonk/ansible-dotfiles/blob/master/tasks/fonts.yml
  #   - name: Cloning fonts
  #     git:
  #       repo=https://github.com/powerline/fonts
  #       dest="/home/vagrant/powerlinefonts"
  #       accept_hostkey=yes
  #     register: fontCloned
  #     become: yes
  #     become_user: vagrant

  #   - name: Install Fonts
  #     shell: /home/vagrant/powerlinefonts/install.sh chdir=/home/vagrant/powerlinefonts
  #     when: fontCloned is success
  #     become: yes
  #     become_user: vagrant

  pre_tasks:

    - name: ensure directories exist
      file:
        dest: "~/{{ item }}"
        state: directory
        mode: 0700
      loop:
        - .bin
        - bin
        - .local/bin
        - ~/.oh-my-zsh/custom/plugins
        - ~/.zsh
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"


    - name: 'Cloning goenv | based on https://github.com/syndbg/goenv/blob/master/INSTALL.md'
      git:
        repo=https://github.com/syndbg/goenv
        dest="~/.goenv"
        accept_hostkey=yes
      register: goenvCloned
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"
      # when: not (bossjones__oh__my__zsh__user == 'root' and ansible_os_family == 'Darwin')

    # # SOURCE: https://github.com/veggiemonk/ansible-dotfiles/blob/master/tasks/fonts.yml
    # - name: 'Cloning fonts | based on https://gist.github.com/ganapativs/e571d9287cb74121d41bfe75a0c864d7'
    #   git:
    #     repo=https://github.com/powerline/fonts
    #     dest="~/powerlinefonts"
    #     accept_hostkey=yes
    #     depth=1
    #   register: fontCloned
    #   become: yes
    #   become_user: "{{ bossjones__oh__my__zsh__user }}"
    #   when: not (bossjones__oh__my__zsh__user == 'root' and ansible_os_family == 'Darwin')

    # - name: 'Cloning iterm2-snazzy theme, dont forget to double click ~/iterm2-snazzy/Snazzy.itermcolors'
    #   git:
    #     repo=https://github.com/sindresorhus/iterm2-snazzy
    #     dest="~/iterm2-snazzy"
    #     accept_hostkey=yes
    #   become: yes
    #   become_user: "{{ bossjones__oh__my__zsh__user }}"
    #   when: not (bossjones__oh__my__zsh__user == 'root' and ansible_os_family == 'Darwin')

    # - name: Install Fonts
    #   shell: ~/powerlinefonts/install.sh chdir=~/powerlinefonts
    #   # when: fontCloned is success
    #   become: yes
    #   become_user: "{{ bossjones__oh__my__zsh__user }}"
    #   when: (fontCloned is success) and not (bossjones__oh__my__zsh__user == 'root' and ansible_os_family == 'Darwin')

    # - name: 'brew tap homebrew/cask-fonts'
    #   homebrew_tap:
    #     name: homebrew/cask-fonts
    #     state: present
    #   # brew don't work from root user on macOS
    #   become: yes
    #   become_user: "{{ bossjones__oh__my__zsh__user }}"
    #   when: not (bossjones__oh__my__zsh__user == 'root' and ansible_os_family == 'Darwin')

    # - name: Install font-fira-code
    #   homebrew_cask:
    #     name: "{{ item }}"
    #     state: present
    #   with_items:
    #     - font-fira-code
    #   # brew don't work from root user on macOS
    #   become: yes
    #   become_user: "{{ bossjones__oh__my__zsh__user }}"
    #   when: not (bossjones__oh__my__zsh__user == 'root' and ansible_os_family == 'Darwin')

    - name: Install/Setup asdf and direnv
      package:
        name: '{{ item }}'
        state: latest
      with_items:
        - zsh
        # - asdf
        # NOTE: I probably really don't need these, but the oh-my-zsh plugins need certain things to exist in order for it to setup the plugin properly
        - peco
        - xdotool
        - mlocate
        - tmux
        - rbenv
        - golang
        - tmuxinator
        - openssh-client
        - fd-find
        - gawk
        - libnotify
        # - pyenv
        # - coreutils
        # - findutils
        # - gnu-tar
        # - gnu-sed
        # - gawk
        # - gnutls
        # - gnu-indent
        # - gnu-getopt
        # - grep
        # - reattach-to-user-namespace
        # - fpp
        - urlview
        - xsel
        - direnv
      become: yes
      # become_user: "{{ bossjones__oh__my__zsh__user }}"
      # when: not (bossjones__oh__my__zsh__user == 'root' and ansible_os_family == 'Darwin')

    # git clone https://github.com/pyenv/pyenv-virtualenvwrapper.git $(pyenv root)/plugins/pyenv-virtualenvwrapper
    - name: Clone fzpyenv-virtualenvwrapper
      git:
        repo: https://github.com/pyenv/pyenv-virtualenvwrapper.git
        dest: "~/.pyenv/plugins/pyenv-virtualenvwrapper"
        version: "master"
        force: yes
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"
      register: bossjones__oh__my__zsh__register_pyenv_virtualenvwrapper

    - name: Clone unixorn git-extra-commands
      git:
        repo: https://github.com/unixorn/git-extra-commands.git
        dest: "~/.oh-my-zsh/custom/plugins/git-extra-commands"
        version: "master"
        force: yes
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"
      register: bossjones__oh__my__zsh__register_git_extra_commands

      # mkdir -p "$HOME/.zsh"
      # git clone https://github.com/sindresorhus/pure.git "$HOME/.zsh/pure"
    - name: Clone pure
      git:
        repo: https://github.com/sindresorhus/pure.git
        dest: "~/.zsh/pure"
        version: "master"
        force: yes
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"
      register: bossjones__oh__my__zsh__register_pure

    - name: Clone zsh-peco-history
      git:
        repo: https://github.com/jimeh/zsh-peco-history.git
        dest: "~/.oh-my-zsh/custom/plugins/zsh-peco-history"
        version: "master"
        force: yes
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"
      register: bossjones__oh__my__zsh__register_zsh_peco_history

    - name: Clone chrissicool zsh-256color
      git:
        repo: https://github.com/chrissicool/zsh-256color.git
        dest: "~/.oh-my-zsh/custom/plugins/zsh-256color"
        version: "master"
        force: yes
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"
      register: bossjones__oh__my__zsh__register_zsh_256color

      # git clone https://github.com/jimeh/zsh-peco-history.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-peco-history

    # git clone https://github.com/jimeh/zsh-peco-history.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-peco-history

    # - name: Clone fzf
    #   git:
    #     repo: https://github.com/junegunn/fzf.git
    #     dest: "~/.fzf"
    #     version: "0.22.0"
    #     force: yes
    #   become: yes
    #   become_user: "{{ bossjones__oh__my__zsh__user }}"
    #   register: bossjones__oh__my__zsh__register_fzf

    - name: Install fzf
      shell: |
        git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf || true
        ~/.fzf/install --all
      # args:
      #   chdir: "~/.fzf"
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"

    - name: fzf-drafts | download
      shell: |
        curl -L 'https://raw.githubusercontent.com/jan-warchol/dotfiles/master/bin/fzf-drafts' > ~/bin/fzf-drafts;
        chmod +x ~/bin/fzf-drafts;
      args:
        executable: /bin/bash
      changed_when: false
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"

    - name: 'compaudit | figure out if anything to fix'
      shell: |
        autoload -U compaudit compinit
        compaudit | wc -l
      args:
        executable: /usr/bin/zsh
      register: compaudit_word_count
      changed_when: false
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"

    - name: 'compaudit | fix'
      shell: |
          autoload -U compaudit compinit
          compaudit | xargs chmod g-w,o-w
          compaudit | xargs chown "{{ bossjones__oh__my__zsh__user }}"
          rm ~/.zcompdump*
      args:
        executable: /usr/bin/zsh
      changed_when: false
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"
      when: compaudit_word_count.stdout != "0"

    - name: 'ensure directories are owned correctly for zsh completion to work'
      shell: |
          chown {{ bossjones__oh__my__zsh__user }}:{{ bossjones__oh__my__zsh__group }} -Rv {{ item }}
      args:
        executable: /usr/bin/zsh
      loop:
        - '/usr/local/share/zsh/site-functions'
        - '/usr/local/share/zsh'
      become: yes
      become_user: "root"
      changed_when: false

    # - name: 'ensure directories are owned correctly for zsh completion to work'
    #   file:
    #     dest: "{{ item }}"
    #     state: directory
    #     owner: "{{ bossjones__oh__my__zsh__user }}"
    #     group: "{{ bossjones__oh__my__zsh__group }}"
    #     recurse: yes
    #   loop:
    #     - '/usr/local/share/zsh/site-functions'
    #     - '/usr/local/share/zsh'
    #   become: yes
    #   become_user: "root"
    #   # when: not (bossjones__oh__my__zsh__user == 'root' and ansible_os_family == 'Darwin')


    # # SOURCE: https://github.com/veggiemonk/ansible-dotfiles/blob/master/tasks/fonts.yml
    # - name: Cloning fonts
    #   git:
    #     repo=https://github.com/powerline/fonts
    #     dest="/home/vagrant/powerlinefonts"
    #     accept_hostkey=yes
    #   register: fontCloned
    #   become: yes
    #   become_user: vagrant

    # - name: Install Fonts
    #   shell: /home/vagrant/powerlinefonts/install.sh chdir=/home/vagrant/powerlinefonts
    #   when: fontCloned is success
    #   become: yes
    #   become_user: vagrant

    # - name: bossjones debug-tools install
    #   shell: |
    #     git clone https://github.com/bossjones/debug-tools /usr/local/src/debug-tools || true
    #     sudo chown {{ bossjones__oh__my__zsh__user }}:{{ bossjones__oh__my__zsh__user }} -Rv ~{{ bossjones__oh__my__zsh__user }} || true
    #     /usr/local/src/debug-tools/update-bossjones-debug-tools
    #     sudo chown {{ bossjones__oh__my__zsh__user }}:{{ bossjones__oh__my__zsh__user }} -Rv ~{{ bossjones__oh__my__zsh__user }} || true
    #   args:
    #     executable: /bin/bash
    #   changed_when: false
    #   become: yes
    #   become_user: "{{ bossjones__oh__my__zsh__user }}"


    - name: "create /usr/local/bin/install-config"
      copy:
        content: |
          export PYENV_VERSIONS_TO_INSTALL="3.9.0\n3.9.8\n"
          export PYENV_ROOT=~/.pyenv
          export PATH="${PYENV_ROOT}/bin:${PYENV_ROOT}/shims:$PATH"
          export RBENV_ROOT=~/.rbenv
          export RBENV_VERSION=2.7.2
          export NODE_VERSION_TO_INSTALL=16.13.1
          export PATH="$HOME/.fnm:${RBENV_ROOT}/shims:${RBENV_ROOT}/bin:$PATH"
        dest: "/usr/local/bin/install-config"
        owner: "{{ bossjones__oh__my__zsh__user }}"
        group: "{{ bossjones__oh__my__zsh__group }}"
        mode: 0755

    - name: fnm | download
      shell: |
        export NODE_VERSION_TO_INSTALL=16.13.1
        install-fnm.sh
        export PATH=~/.fnm:$PATH
        eval "`fnm env --use-on-cd`"
        if [ "$(fnm ls | grep -i {{NODE_VERSION_TO_INSTALL}} | wc -l)" = "0" ]; then
          fnm install {{NODE_VERSION_TO_INSTALL}} || true
          fnm use {{NODE_VERSION_TO_INSTALL}} || true
          fnm default {{NODE_VERSION_TO_INSTALL}} || true
          fnm current || true
          npm install -g pure-prompt || true
          npm install -g pretty-time-zsh || true
        fi
      args:
        executable: /bin/bash
      changed_when: false
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"

    # SOURCE: https://github.com/k3s-io/k3s-ansible/blob/master/roles/prereq/tasks/main.yml
    - name: Enable IPv4 forwarding
      sysctl:
        name: net.ipv4.ip_forward
        value: "1"
        state: present
        reload: yes

    - name: Enable IPv6 forwarding
      sysctl:
        name: net.ipv6.conf.all.forwarding
        value: "1"
        state: present
        reload: yes
