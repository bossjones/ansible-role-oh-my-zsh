# USAGE: sudo ansible-playbook --ask-become-pass --check -i "localhost," -c local playbook_ubuntu_pure.yml --extra-vars="bossjones__oh__my__zsh__user=$(whoami) bossjones__oh__my__zsh__theme=powerlevel"
###########################################################################
# ON APPLE M1 DEVICES YOU NEED TO RUN THE FOLLOWING
###########################################################################
# USAGE: sudo ansible-playbook --ask-become-pass --check -i "localhost," -c local playbook_ubuntu_pure.yml --extra-vars="bossjones__oh__my__zsh__user=$(whoami) bossjones__oh__my__zsh__theme=pure bossjones__oh__my__zsh__path_to_shell=/opt/homebrew/bin/zsh"
###########################################################################
# ON APPLE INTEL DEVICES YOU NEED TO RUN THE FOLLOWING
###########################################################################
# USAGE: sudo ansible-playbook --ask-become-pass --check -i "localhost," -c local playbook_ubuntu_pure.yml --extra-vars="bossjones__oh__my__zsh__user=$(whoami) bossjones__oh__my__zsh__theme=pure bossjones__oh__my__zsh__path_to_shell=/usr/local/bin/zsh"
# sudo ansible-playbook --ask-become-pass --check -i "localhost," -c local playbook_ubuntu_pure.yml --extra-vars="bossjones__oh__my__zsh__user=$(whoami) bossjones__oh__my__zsh__theme=pure"
---

- hosts: localhost
  become: yes
  become_method: sudo
  vars:
    bossjones__oh__my__zsh__pyenv_version: 2.2.3
    bossjones__oh__my__zsh__theme: "pure"
    NODE_VERSION_TO_INSTALL: 16.13.1
    FZF_VERSION: 0.29.0
    ASDF_VERSION: 0.9.0
    rbenv:
      env: system
      version: v1.1.2
      default_ruby: 2.7.2
      rubies:
        - version: 2.7.2

    rbenv_clean_up: false

    rbenv_repo: "https://github.com/rbenv/rbenv.git"

    rbenv_plugins:
      - { name: "rbenv-vars",         repo: "https://github.com/rbenv/rbenv-vars.git",         version: "master" }
      - { name: "ruby-build",         repo: "https://github.com/rbenv/ruby-build.git",         version: "master" }
      - { name: "rbenv-default-gems", repo: "https://github.com/rbenv/rbenv-default-gems.git", version: "master" }
      - { name: "rbenv-installer",    repo: "https://github.com/rbenv/rbenv-installer.git",    version: "master" }
      - { name: "rbenv-update",       repo: "https://github.com/rkh/rbenv-update.git",         version: "master" }
      - { name: "rbenv-whatis",       repo: "https://github.com/rkh/rbenv-whatis.git",         version: "master" }
      - { name: "rbenv-use",          repo: "https://github.com/rkh/rbenv-use.git",            version: "master" }

    rbenv_root: "{% if rbenv.env == 'system' %}/usr/local/rbenv{% else %}~/.rbenv{% endif %}"

    rbenv_set_vars: true

    rbenv_users: []

    rbenv_extra_depends:
    - libssl1.0-dev
    - build-essential
    - bison
    - ruby-dev
    - rake
    - zlib1g-dev
    - libyaml-dev
    - libssl-dev
    - libreadline-dev
    - libncurses5-dev
    - llvm
    - llvm-dev
    - libeditline-dev
    - libedit-dev
    rbenv_apt_packages:
    - build-essential
    - curl
    - git
    - libcurl4-openssl-dev
    - libffi-dev
    - libreadline-dev
    - libssl-dev
    - libxml2-dev
    - libxslt1-dev
    - zlib1g-dev
    rbenv_dnf_packages:
    - curl
    - gcc
    - openssl-devel
    - libyaml-devel
    - readline-devel
    - zlib-devel
    - libffi-devel
    - git
    rbenv_yum_packages:
    - bzip2
    - curl
    - gcc
    - git
    - libffi-devel
    - libyaml-devel
    - openssl-devel
    - readline-devel
    - zlib-devel
    rbenv_user_profile: true
    bossjones__oh__my__zsh__enable_zlogin: "yes"
    bossjones__oh__my__zsh__enable_zlogout: "yes"
    bossjones__oh__my__zsh__enable_zprofile: "yes"
    bossjones__oh__my__zsh__enable_zshenv: "yes"
    bossjones__oh__my__zsh__change_default_shell: false
    # bossjones__oh__my__zsh__path_to_shell: /opt/homebrew/bin/zsh
    bossjones__oh__my__zsh__antigen_bundles_extras:
      # Solarized dircolors plugin for zsh
      - joel-porquet/zsh-dircolors-solarized

      # peco/percol/fzf wrapper plugin for zsh
      - mollifier/anyframe

      #  A utility tool powered by fzf for using git interactively.
      - wfxr/forgit

      - { name: eventi/noreallyjustfuckingstopalready, command: killall }
      # https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins
      - { name: vscode, command: code }
      - { name: gpg-agent, command: gpg-agent }
      - history
      - { name: fd, command: fd }
      - { name: autopep8, command: autopep8 }
      - { name: pylint, command: pylint }
      - { name: ELLIOTTCABLE/rbenv.plugin.zsh, command: ruby }
      - { name: colored-man-pages, command: man }

      - { name: bossjones/boss-git-zsh-plugin, command: git }
      - { name: bossjones/boss-docker-zsh-plugin, command: docker }

      # A zsh plugin to sync git repositories and clean them up.
      - caarlos0/zsh-git-sync

      # This ZSH plugin enhances the terminal environment with 256 colors. It looks at the chosen TERM environment variable and sees if there is respective (n-)curses' termcap/terminfo descriptors for 256 colors available. The result is a multicolor terminal, if available.
      - chrissicool/zsh-256color

      # Desktop notifications for long-running commands in zsh.
      - marzocchi/zsh-notify
      # Add zsh's missing hooks, and support for user-defined hooks
      - zsh-hooks/zsh-hooks

      # A collection of git utilities and useful extra git scripts I've discovered or written, packaged for ease of use with shell frameworks.
      - unixorn/git-extra-commands@main

      # alias for docker aliases
      - { name: hadenlabs/zsh-docker@main, command: docker }
      # servers functions for shell
      # - luismayta/zsh-servers-functions
      # Search ssh connect with peco
      # - { name: luismayta/zsh-peco-ssh-connect, command: peco }

      # Plugin for lazy-loading pyenv in zsh.
      - { name: erikced/zsh-pyenv-lazy-load, command: pyenv }

      # - { name: vagrant, command: vagrant }

      # Convert seconds to a human readable string: 165392 â†’ 1d 21h 56m 32s
      - sindresorhus/pretty-time-zsh@main

      # Because your terminal should be able to perform tasks asynchronously without external tools!
      # - mafredri/zsh-async

      - asdf
      # Pretty, minimal and fast ZSH prompt
      - sindresorhus/pure@main

      # stuff that has to be last
      - zdharma-continuum/fast-syntax-highlighting@master
      - fnm

    bossjones__oh__my__zsh__autosuggestions_bind_key: "^U"
    bossjones__oh__my__zsh__path:
      - $HOME/bin
      - $HOME/.bin
      - $HOME/.local/bin
      - $HOME/.fnm
      - /usr/local/sbin
      - /usr/local/bin
      - /usr/sbin
      - /usr/bin
      - /sbin
      - /bin

    bossjones__oh__my__zsh__zlogout: |-
      # .zlogout

    # borrowed from https://github.com/Gipetto/dot-files/blob/ed422b7c16c0d82b2c7f901c25c945afe13d570a/zsh/zprofile
    # TODO: Lets also look at this: https://github.com/mattmc3/zdotdir
    bossjones__oh__my__zsh__zprofile: |-
      # .zprofile: similar to .zlogin but loaded before .zshrc( .zprofile and .zshrc are ignored in non-login non-interactive shells - so I learned a trick from Prezto that declares environment variables in .zprofile and uses .zshenv to source .zprofile (eg .zprofile and .zshenv) This way, non-login non-interactive shells will receive proper variable initialisations).
      # See presto for orig - https://github.com/sorin-ionescu/prezto/blob/master/runcoms/zprofile

      # XDG
      # https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html
      # https://wiki.archlinux.org/index.php/XDG_Base_Directory
      # https://wiki.archlinux.org/index.php/XDG_user_directories

      export XDG_CONFIG_HOME=~/.config
      export XDG_CACHE_HOME=~/.cache
      export XDG_DATA_HOME=~/.local/share
      export XDG_RUNTIME_DIR=~/.xdg

      if [[ "$OSTYPE" == darwin* ]]; then
        export XDG_DESKTOP_DIR=~/Desktop
        export XDG_DOCUMENTS_DIR=~/Documents
        export XDG_DOWNLOAD_DIR=~/Downloads
        export XDG_MUSIC_DIR=~/Music
        export XDG_PICTURES_DIR=~/Pictures
        export XDG_VIDEOS_DIR=~/Videos
        export XDG_PROJECTS_DIR=~/Projects
      fi

      if [[ "$OSTYPE" == darwin* ]]; then
        export BROWSER='open'
      fi

      _ARCH=$(uname -m)
      if [[ "${_ARCH}" = "arm64" ]]; then
          _MY_OPT_HOMEBREW=/opt/homebrew
      else
          _MY_OPT_HOMEBREW=/usr/local
      fi

      # FIXME: bossjones added this section out of order ( I think it's probably important to have homebrew initialized before anything else )
      # SOURCE: https://github.com/Gipetto/dot-files/blob/ed422b7c16c0d82b2c7f901c25c945afe13d570a/zsh/zprofile

      local OPT_HOMEBREW="${_MY_OPT_HOMEBREW}"
      if [[ -s "$OPT_HOMEBREW"/bin/brew ]]; then
          eval "$($OPT_HOMEBREW/bin/brew shellenv)"
      fi

      if [[ -s "$HOMEBREW_PREFIX"/opt/asdf/libexec/asdf.sh ]]; then
        ASDF_DIR="${HOMEBREW_PREFIX}/opt/asdf/libexec"
        ASDF_COMPLETIONS="$ASDF_DIR/completions"
        . "$HOMEBREW_PREFIX"/opt/asdf/libexec/asdf.sh
        fpath=(${ASDF_DIR}/completions $fpath)
      elif [[ -s "$HOME/.asdf/asdf.sh" ]]; then
        . "$HOME"/.asdf/asdf.sh
      fi

      if [[ -d "$HOMEBREW_PREFIX"/opt/coreutils/libexec/gnubin ]]; then
        path=(${HOMEBREW_PREFIX}/opt/coreutils/libexec/gnubin $path)
      fi

      if [[ -s "$HOMEBREW_PREFIX"/opt/pyenv/libexec/pyenv ]]; then
            eval "$(${HOMEBREW_PREFIX}/opt/pyenv/libexec/pyenv init --path)"
            eval "$(${HOMEBREW_PREFIX}/opt/pyenv/libexec/pyenv init -)"
            fpath=(${HOMEBREW_PREFIX}/opt/pyenv/completions $fpath)
            pyenv virtualenvwrapper_lazy

          elif [[ -s "$HOME/.pyenv/bin/pyenv" ]]; then
            export PYENV_ROOT=~/.pyenv
            export PATH="$PYENV_ROOT/bin:$PATH"
            eval "$(pyenv init --path)"
            eval "$(pyenv init -)"
            pyenv virtualenvwrapper_lazy
      fi

      # SOURCE: https://github.com/ajh/dotfiles/blob/master/configs/zsh/dot_zshrc
      {{bossjones__oh__my__zsh__before_block}}

      # FIXME: bossjones added this section out of order

      # less pipe
      # https://github.com/wofr06/lesspipe/blob/lesspipe/INSTALL
      # Set the default Less options
      # Mouse-wheel scrolling has been disabled by -X (disable screen clearing)
      # Remove -X to enable it
      export LESS='-g -i -M -R -S -w -z-4'

      # Set the Less input preprocessor
      # Try both `lesspipe` and `lesspipe.sh` as either might exist on a system
      if (( $#commands[(i)lesspipe(|.sh)] )); then
        export LESSOPEN="| /usr/bin/env $commands[(i)lesspipe(|.sh)] %s 2>&-"
      fi

      export EDITOR='vim'
      export VISUAL='code'
      export PAGER='less'

      export TZ="America/New_York"
      export LANG="en_US.UTF-8"
      export LANGUAGE="en"
      export LC_ALL="en_US.UTF-8"

      # SOURCE: https://zsh.sourceforge.io/Doc/Release/Shell-Builtin-Commands.html
      # The -g (global) means that any resulting parameter will not be restricted to local scope. Note that this does not necessarily mean that the parameter will be global, as the flag will apply to any existing parameter (even if unset) from an enclosing function. This flag does not affect the parameter after creation, hence it has no effect when listing existing parameters, nor does the flag +g have any effect except in combination with -m (see below).

      # -U
      # For arrays (but not for associative arrays), keep only the first occurrence of each duplicated value. This may also be set for tied parameters (see -T) or colon-separated special parameters like PATH or FIGNORE, etc. Note the flag takes effect on assignment, and the type of the variable being assigned to is determinative; for variables with shared values it is therefore recommended to set the flag for all interfaces, e.g. 'typeset -U PATH path'.

      # This flag has a different meaning when used with -f; see below.
      # Ensure path arrays do not contain duplicates
      typeset -gU cdpath fpath mailpath path

      # The $path array variable is tied to the $PATH scalar (string) variable. Any modification on one is reflected in the other.
      path=(
        $HOME/bin
        $HOME/.bin
        $HOME/.local/bin
        $HOME/.fnm
        /usr/local/sbin
        /usr/local/bin
        /usr/sbin
        /usr/bin
        /sbin
        /bin
        $path
      )
      [[ -d $ZDOTDIR/bin ]] && path+=($ZDOTDIR/bin)

      # https://apple.stackexchange.com/questions/427561/macos-zsh-sessions-zsh-history-and-setopt-append-history
      # To disable Apple's shell state code, add to your .zshenv file:
      # export SHELL_SESSIONS_DISABLE=1

      # Then add to your .zshrc file:

      # setopt sharehistory
      # Also, make sure you unset all options incompatible with SHARE_HISTORY. Again, read https://zsh.sourceforge.io/Doc/Release/Options.html#History for more info.

      # Finally, feel free to delete the .zsh_sessions dir created by Apple's code, as it will no longer be necessary.

      ##################################################### ends here



      # SOURCE: https://github.com/Gipetto/dot-files/blob/ed422b7c16c0d82b2c7f901c25c945afe13d570a/zsh/zprofile - END

    bossjones__oh__my__zsh__zshenv: |-
      # Since .zshenv is always sourced, it often contains exported variables that should be available to other programs. For example, $PATH, $EDITOR, and $PAGER are often set in .zshenv. Also, you can set $ZDOTDIR in .zshenv to specify an alternative location for the rest of your zsh configuration.
      # ~/.zshenv: system-wide .zshenv file for zsh(1).
      #
      # This file is sourced on all invocations of the shell.
      # If the -f flag is present or if the NO_RCS option is
      # set within this file, all other initialization files
      # are skipped.
      #
      # This file should contain commands to set the command
      # search path, plus other important environment variables.
      # This file should not contain commands that produce
      # output or assume the shell is attached to a tty.
      #
      # Global Order: zshenv, zprofile, zshrc, zlogin

      # # TODO: Do we want to keep this here?
      # export RBENV_ROOT=~/.rbenv
      # export GOENV_ROOT=$HOME/.goenv

      # if [[ -z "$PATH" || "$PATH" == "/bin:/usr/bin" ]]
      # then
      #   export PATH="/usr/local/bin:/usr/bin:/bin"
      #   export PATH="~/.rbenv/shims:$HOME/bin:$HOME/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH"
      #   export PATH="${GOENV_ROOT}/bin:${PATH}"
      # fi


      # SOURCE: https://github.com/mattmc3/zdotdir/blob/main/.zshenv - START
      # ~/.zshenv should only be a one-liner that sources this file
      # echo ". ~/.config/zsh/.zshenv" > ~/.zshenv

      # XDG apps
      # define variables/aliases for different apps to use XDG locations

      # https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html
      # https://wiki.archlinux.org/index.php/XDG_Base_Directory
      # https://wiki.archlinux.org/index.php/XDG_user_directories

      export XDG_CONFIG_HOME=${XDG_CONFIG_HOME:-$HOME/.config}
      export XDG_CACHE_HOME=${XDG_CACHE_HOME:-$HOME/.cache}
      export XDG_DATA_HOME=${XDG_DATA_HOME:-$HOME/.local/share}
      export XDG_RUNTIME_DIR=${XDG_RUNTIME_DIR:-$HOME/.xdg}

      if [[ "$OSTYPE" == darwin* ]]; then
        export XDG_DESKTOP_DIR=${XDG_DESKTOP_DIR:-$HOME/Desktop}
        export XDG_DOCUMENTS_DIR=${XDG_DOCUMENTS_DIR:-$HOME/Documents}
        export XDG_DOWNLOAD_DIR=${XDG_DOWNLOAD_DIR:-$HOME/Downloads}
        export XDG_MUSIC_DIR=${XDG_MUSIC_DIR:-$HOME/Music}
        export XDG_PICTURES_DIR=${XDG_PICTURES_DIR:-$HOME/Pictures}
        export XDG_VIDEOS_DIR=${XDG_VIDEOS_DIR:-$HOME/Videos}
        export XDG_PROJECTS_DIR=${XDG_PROJECTS_DIR:-$HOME/Projects}
      fi

      # **********************************************************
      # GUIDE TO READ SNIPPET OF CODE BELOW:
      # **********************************************************
      # SHLVL=1 means this is the first level of a zsh shell
      # -o LOGIN means a shell built in option with that name is on
      # -s file ~/.zprofile exists and is greater than zero
      # Ensure that a non-login, non-interactive shell has a defined environment.
      if [[ ( "$SHLVL" -eq 1 && ! -o LOGIN ) && -s "${ZDOTDIR:-$HOME}/.zprofile" ]]; then
        source "${ZDOTDIR:-$HOME}/.zprofile"
      fi
      # **********************************************************
      # SOURCE: https://github.com/mattmc3/zdotdir/blob/main/.zshenv - END


      skip_global_compinit=1

    # /usr/local/rbenv/shims:/home/vagrant/bin:/home/vagrant/.local/bin:/home/vagrant/.pyenv/bin:/home/vagrant/.rbenv/bin:/home/vagrant/.fnm:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games

    bossjones__oh__my__zsh__zlogin: |-
      # https://unix.stackexchange.com/questions/71253/what-should-shouldnt-go-in-zshenv-zshrc-zlogin-zprofile-zlogout
      #
      # Executes commands at login post-zshrc.
      #
      # Authors:
      #   Sorin Ionescu <sorin.ionescu@gmail.com>
      #
      # /etc/zsh/zlogin: system-wide .zlogin file for zsh(1).
      #
      # This file is sourced only for login shells. It
      # should contain commands that should be executed only
      # in login shells. It should be used to set the terminal
      # type and run a series of external commands (fortune,
      # msgs, from, etc.)
      #
      # Global Order: zshenv, zprofile, zshrc, zlogin

      # source ~/.zshrc

      #
      # Executes commands at login post-zshrc.
      #
      # Authors:
      #   Sorin Ionescu <sorin.ionescu@gmail.com>
      #

      # Execute code that does not affect the current session in the background.
      # VIA: https://github.com/sorin-ionescu/prezto/blob/704fc46c3f83ca1055becce65fb513a533f48982/runcoms/zlogin

      # {
      #   # Compile the completion dump to increase startup speed.
      #   zcompdump="${XDG_CACHE_HOME:-$HOME/.cache}/prezto/zcompdump"
      #   if [[ -s "$zcompdump" && (! -s "${zcompdump}.zwc" || "$zcompdump" -nt "${zcompdump}.zwc") ]]; then
      #     zcompile "$zcompdump"
      #   fi
      # } &!

      # # Within zsh the command &! is a shortcut for disown, i.e. the program won't get killed upon exiting the invoking shell.
      # # https://stackoverflow.com/questions/44893896/what-does-ampersand-and-exclamation-mean-in-linux-shell/44894182
      # {
      #   autoload -Uz compinit
      #   compinit -u
      # } &!

      # # Execute code only if STDERR is bound to a TTY.
      # if [[ -o INTERACTIVE && -t 2 ]]; then

      #   # Print a random, hopefully interesting, adage.
      #   if (( $+commands[fortune] )); then
      #     fortune -s
      #     print
      #   fi

      # fi >&2


    bossjones__oh__my__zsh__before_scripts:
      - name: secrets.zsh
        content: |-
          # [ -f ~/.secret ] && . ~/.secret
          # NOTE: I modified this after seeing how he treats certain conditionals
          # https://github.com/mcornella/dotfiles/blob/main/zshenv
          test -f "$HOME/.secret" && . "$HOME/.secret"

      # NOTE: Since this is a mac, we want to use the homebrew version of
      # - name: asdf.zsh
      #   content: |-
      #     ASDF_DIR="${ASDF_DIR:-$HOME/.asdf}"
      #     ASDF_COMPLETIONS="$ASDF_DIR/completions"

      #     # if [ -d "$HOME/.asdf" ]; then

      #     #   . $HOME/.asdf/asdf.sh
      #     # fi

      #     # Load command
      #     if [[ -f "$ASDF_DIR/asdf.sh" ]]; then
      #         . "$ASDF_DIR/asdf.sh"

      #         fpath=(${ASDF_DIR}/completions $fpath)

      #         # Load completions
      #         if [[ -f "$ASDF_COMPLETIONS/asdf.bash" ]]; then
      #             . "$ASDF_COMPLETIONS/asdf.bash"
      #         fi

      #         # autoload -Uz compinit
      #         # compinit
      #     fi

      - name: rbenv.zsh
        content: |


          _ARCH=$(uname -m)
          if [[ "${_ARCH}" = "arm64" ]]; then
              _MY_OPT_HOMEBREW=/opt/homebrew
          else
              _MY_OPT_HOMEBREW=/usr/local
          fi

          export OPT_HOMEBREW="${_MY_OPT_HOMEBREW}"
          # export OPT_HOMEBREW="/opt/homebrew"
          if [[ -s "$OPT_HOMEBREW"/bin/brew ]]; then
              eval "$($OPT_HOMEBREW/bin/brew shellenv)"
          fi

          if [[ -s "$HOMEBREW_PREFIX"/opt/rbenv/libexec/rbenv ]]; then
              eval "$(${HOMEBREW_PREFIX}/opt/rbenv/libexec/rbenv init -)"
              fpath=(${HOMEBREW_PREFIX}/opt/rbenv/completions $fpath)
              # autoload -Uz compinit
              # compinit
          fi

          # if [ -e ~/.rbenv ]; then
          #   export PATH="~/.rbenv/shims:$PATH"
          # fi

          # # NOTE: Anything with an export, lets put in curly brackets
          # test -e "$HOME/.rbenv" && {
          #   export PATH="$HOME/.rbenv/shims:$PATH"
          # }

          # # SOURCE: https://github.com/rbenv/rbenv/issues/418
          # # NOTE: theres a which binary and a which shell builtin. by setting command, we are using the builtin.
          # # Like @graywh said: which can be either a shell builtin or a command in your PATH. To see which you are using: type which
          # # What you are seeing as a result for which rbenv is correct. If you want to detect the path to the rbenv executable, you can use command which rbenv.

          # if [[ -x $(command which rbenv) ]]; then
          #   eval "$(rbenv init -)"
          # fi

      - name: rust.zsh
        content: |-
          # if [ -d "$HOME/.cargo/bin" ]; then
          #   export PATH=$HOME/.cargo/bin:$PATH
          # fi

          # NOTE: I modified this after seeing how he treats certain conditionals
          # https://github.com/mcornella/dotfiles/blob/main/zshenv

          test -d "$HOME/.cargo/bin" && {
            export PATH=$HOME/.cargo/bin:$PATH
          }

      - name: go.zsh
        content: |-
          # if [ -d "/usr/local/go/bin" ]; then
          #   export PATH=/usr/local/go/bin:$PATH
          # fi

          # NOTE: I modified this after seeing how he treats certain conditionals
          # https://github.com/mcornella/dotfiles/blob/main/zshenv

          test -d "$(brew --prefix go)" && {
            export PATH="$(brew --prefix go)/bin:${PATH}"
            export PATH=$GOPATH/bin:$PATH
            alias cdgo='CDPATH=.:$GOPATH/src/github.com:$GOPATH/src/golang.org:$GOPATH/src'
          }



          test -d "$HOME/.goenv" && {
            export GOENV_ROOT="$HOME/.goenv"
            export PATH="$GOENV_ROOT/bin:$PATH"
            eval "$(goenv init -)"
            export PATH="$GOROOT/bin:$PATH"
            export PATH="$PATH:$GOPATH/bin"
          }



      - name: workon.zsh
        content: |-
          export WORKON_HOME="$HOME/.pyenv/versions"
          export PROJECT_HOME=$HOME/dev

      - name: fzf.zsh
        content: |-
          # [ -f ~/.fzf.zsh ] && . ~/.fzf.zsh

          # NOTE: I modified this after seeing how he treats certain conditionals
          # https://github.com/mcornella/dotfiles/blob/main/zshenv

          test -f "$HOME/.fzf.zsh" && . "$HOME/.fzf.zsh"

      - name: pure.zsh
        content: |-
          # if [ -d "$HOME/.zsh/pure" ]; then
          #   fpath+=$HOME/.zsh/pure
          # fi

          # NOTE: I modified this after seeing how he treats certain conditionals
          # https://github.com/mcornella/dotfiles/blob/main/zshenv

          # SOURCE: https://unix.stackexchange.com/questions/33255/how-to-define-and-load-your-own-shell-function-in-zsh
          # https://zsh.sourceforge.io/Doc/Release/Functions.html
          # # fpath info
          # # In zsh, the function search path ($fpath) defines a set of directories, which contain files that can be marked to be loaded automatically when the function they contain is needed for the first time.

          # Zsh has two modes of autoloading files: Zsh's native way and another mode that resembles ksh's autoloading. The latter is active if the KSH_AUTOLOAD option is set. Zsh's native mode is the default and I will not discuss the other way here (see "man zshmisc" and "man zshoptions" for details about ksh-style autoloading).

          # Let's assume you got a file `~/.zfunc/hello' that contains the following line:

          # printf 'Hello world.\n'
          # All you need to do now is mark the function to be automatically loaded upon its first reference:

          # autoload -Uz hello

          # "What is the -Uz about?", you ask? Well, that's just a set of options that will cause `autoload' to do the right thing, no matter what options are being set otherwise. The `U' disables alias expansion while the function is being loaded and the `z' forces zsh-style autoloading even if `KSH_AUTOLOAD' is set for whatever reason.

          # After that has been taken care of, you can use your new `hello' function:

          # fpath+=$HOME/.zsh/pure
          test -d "${HOME}/.zsh/pure" && {
            fpath=(${HOME}/.zsh/pure $fpath)
          }

      - name: poetry.zsh
        content: |-
          # if [ -d "$HOME/.asdf/installs/poetry/1.0.10/env" ]; then
          #   . $HOME/.asdf/installs/poetry/1.0.10/env
          # fi

          # test -f "$HOME/.fzf.zsh" && . "$HOME/.fzf.zsh"

    bossjones__oh__my__zsh__after_scripts:
      - name: custom_plugins.zsh
        content: |
          plugins+=(git-extra-commands zsh-256color zsh-peco-history pyenv rbenv fd fzf zsh-syntax-highlighting tmux rbenv)

      - name: nvm.zsh
        content: |-
          # removed nvm

      - name: yq.zsh
        content: |-
          if [ -e "${HOME}/.asdf/shims/yq" ]; then
              yq shell-completion zsh > "${fpath[1]}/_yq"
          fi

          if [ -e /usr/local/bin/yq ]; then
              yq shell-completion zsh > "${fpath[1]}/_yq"
          fi

      - name: fnm.zsh
        content: |-
          # SOURCE: https://github.com/Schniz/fnm
          # FROM ONE OF THE OH-MY-ZSH maintainers https://github.com/mcornella/dotfiles/blob/main/zshenv
          # brew --prefix fnm


          _ARCH=$(uname -m)
          if [[ "${_ARCH}" = "arm64" ]]; then
              _MY_OPT_HOMEBREW=/opt/homebrew
          else
              _MY_OPT_HOMEBREW=/usr/local
          fi

          local OPT_HOMEBREW="${_MY_OPT_HOMEBREW}"
          if [[ -s "$OPT_HOMEBREW"/bin/brew ]]; then
              eval "$($OPT_HOMEBREW/bin/brew shellenv)"
          fi

          if [[ -s "$HOMEBREW_PREFIX"/opt/fnm/bin/fnm ]]; then
            eval "$(${HOMEBREW_PREFIX}/opt/fnm/bin/fnm env --use-on-cd)"
          fi

          test -d "$HOME/.fnm" && {
            export PATH=~/.fnm:$PATH
            # export PATH="$PATH:$HOME/.fnm"
            eval "$(fnm env --use-on-cd)"
            test -f "$HOME/.zsh/completions/_fnm" \
            || fnm completions --shell zsh > "$HOME/.zsh/completions/_fnm"
            fpath+=~/.config/zsh/completions/_fnm
          }

          # only run this on login / interactive shells
          if [[ ( "$SHLVL" -eq 1 && ! -o LOGIN ) && -s "${ZDOTDIR:-$HOME}/.zprofile" ]]; then

            if [ -n "$(command which fnm)" ]; then
                eval "$(fnm env --use-on-cd)"
                if [ "$(fnm ls | grep -i {{NODE_VERSION_TO_INSTALL}} | wc -l)" = "0" ]; then
                  fnm install {{NODE_VERSION_TO_INSTALL}} || true
                  fnm use {{NODE_VERSION_TO_INSTALL}} || true
                  fnm default {{NODE_VERSION_TO_INSTALL}} || true
                  fnm current || true
                  npm install -g pure-prompt || true
                  npm install -g pretty-time-zsh || true
                fi
            fi

          fi


      - name: hub.zsh
        content: |-
          # https://github.com/github/hub/issues/1419
          repos_via_hub() {
            local user="${1?}"
            shift 1
            paginate hub api -t graphql -f user="$user" "$@" -f query='
              query($user: String!, $per_page: Int = 100, $after: String) {
                user(login: $user) {
                  repositories(first: $per_page, after: $after) {
                    nodes {
                      nameWithOwner
                    }
                    pageInfo {
                      hasNextPage
                      endCursor
                    }
                  }
                }
              }
            '
          }
          paginate() {
            local output cursor
            output="$("$@")"
            cursor="$(awk '/\.hasNextPage/ { has_next=$2 } /\.endCursor/ { if (has_next=="true") print $2 }' <<<"$output")"
            printf "%s\n" "$output"
            [ -z "$cursor" ] || paginate "$@" -f after="$cursor"
          }
          # USAGE: repos_via_hub "bossjones" | awk '/\.nameWithOwner\t/ { print $2 }'


      - name: vpn.zsh
        content: |-
          alias vpn="sudo openconnect --user=$(whoami) --os=mac-intel asa-virginia-1.adobe.com"

      - name: aws_utils.zsh
        content: |-
          awslookup() {
            # SOURCE: https://engineering.talis.com/articles/bash-awslookup-tool/
            # uses aws cli to lookup instances based on a filter on the Name tag
            # $1 is the filter to use
            # $2 is the output format defaults to 'table'
            # $3 is optional, the value doesn't matter but if passed in will result
            #    in this function printing out the raw command its about to run
            #    for debugging purposes
            cmd="aws ec2 describe-instances --filters \"Name=tag:Name,Values=$1\" --query 'Reservations[].Instances[].[InstanceId,PublicDnsName,PrivateIpAddress,State.Name,InstanceType,join(\`,\`,Tags[?Key==\`Name\`].Value)]' --output ${2:-table}"
            if [ $# -eq 3 ]
            then
              echo "Running $cmd"
            fi
            eval $cmd
          }

      - name: gnubin.zsh
        content: |-
          alias ls="ls --color=always"

      - name: git_cu.zsh
        content: |-
          export GIT_CU_DIR="${HOME}/dev"

      - name: fzf.zsh
        content: |
          test -f "$HOME/.fzf.zsh" && . "$HOME/.fzf.zsh"

          export FZF_TMUX_OPTS="-d 15"

      - name: glob.zsh
        content: |
          # see `man zshoptions`
          setopt EXTENDED_GLOB

      - name: history.zsh
        content: |
          # # see `man zshoptions`
          # # SOURCE: https://linux.die.net/man/1/zshoptions
          # # SOURCE: http://zsh.sourceforge.net/Doc/Release/Options.html
          # # Save each command's beginning timestamp (in seconds since the epoch) and the duration (in seconds) to the history file. The format of this prefixed data is:
          # # ':<beginning time>:<elapsed seconds>:<command>'.
          # setopt EXTENDED_HISTORY

          # # If a new command line being added to the history list duplicates an older one, the older command is removed from the list (even if it is not the previous event).
          # setopt HIST_IGNORE_ALL_DUPS

          # # APPEND_HISTORY <D>
          # # If this is set, zsh sessions will append their history list to the history file, rather than replace it. Thus, multiple parallel zsh sessions will all have the new entries from their history lists added to the history file, in the order that they exit. The file will still be periodically re-written to trim it when the number of lines grows 20% beyond the value specified by $SAVEHIST (see also the HIST_SAVE_BY_COPY option).
          # # --------------------------------------------------
          # # This options works like APPEND_HISTORY except that new history lines are added to the $HISTFILE incrementally (as soon as they are entered), rather than waiting until the shell exits. The file will still be periodically re-written to trim it when the number of lines grows 20% beyond the value specified by $SAVEHIST (see also the HIST_SAVE_BY_COPY option).
          # setopt INC_APPEND_HISTORY

          # setopt INC_APPEND_HISTORY_TIME
          # setopt SHARE_HISTORY

          # SOURCE: https://github.com/balakrishnanc/dotfiles/blob/bff74304808b68ffbc571b2d13d3b8077ce65c4e/zsh/zshenv.template
          # Remove superfluous blanks from each command line being added
          #  to the history list.
          setopt HIST_REDUCE_BLANKS

          # When writing out the history file, older commands that duplicate newer ones
          #  are omitted.
          setopt HIST_SAVE_NO_DUPS

          # If you find that you want more control over when commands get imported,
          #  you may wish to turn SHARE_HISTORY off,
          #  INC_APPEND_HISTORY or INC_APPEND_HISTORY_TIME on, and then manually import
          #  commands whenever you need them using 'fc -RI'.
          unsetopt SHARE_HISTORY

          # This option is a variant of INC_APPEND_HISTORY in which, where possible,
          #  the history entry is written out to the file after the command is finished,
          #  so that the time taken by the command is recorded correctly in the
          #  history file in EXTENDED_HISTORY format. This means that the history entry
          #  will not be available immediately from other instances of the shell that are
          #  using the same history file.
          # This option is only useful if INC_APPEND_HISTORY and SHARE_HISTORY are
          #  turned off. The three options should be considered mutually exclusive.
          setopt INC_APPEND_HISTORY_TIME

          # This options works like APPEND_HISTORY except that new history lines are
          #  added to the $HISTFILE incrementally (as soon as they are entered),
          #  rather than waiting until the shell exits.
          unsetopt INC_APPEND_HISTORY

      - name: man.zsh
        content: |
          get_man_exorts() {
            for i in /usr/local/Cellar/*/*/share/man; do
              echo 'export MANPATH="'$i':$MANPATH"'
            done
            for i in /usr/local/Cellar/*/*/libexec/gnuman; do
              echo 'export MANPATH="'$i':$MANPATH"'
            done
          }

      - name: path.zsh
        content: |
          # if [ -d "$HOME/bin" ]; then
          #   export PATH=$HOME/bin:$PATH
          # fi

          test -d "$HOME/bin" && {
            export PATH=$HOME/bin:$PATH
          }

      - name: cheat.zsh
        content: |
          export CHEAT_CONFIG_PATH="~/.config/cheat/conf.yml"


          cheat_update_personal() {
              pushd ~/.config/cheat/cheatsheets/personal
              git pull --rebase || true
              popd
              cheat -l
          }


      - name: custom.zsh
        content: |
          cp_mp4() {
              rm -fv cp.txt
              touch cp.txt
              mkdir reactions_copy || true
              [ "$(ls *.mp4 | tr " " '\r' | wc -l | awk '{print $1}')" -gt "0" ] && for filename in ./*mp4*; do echo cp -av "${filename}" reactions_copy/; done >> cp.txt
              bash -x cp.txt
          }

          # SOURCE: https://justin.abrah.ms/dotfiles/zsh.html
          # Mac Helpers
          alias show_hidden="defaults write com.apple.Finder AppleShowAllFiles YES && killall Finder"
          alias hide_hidden="defaults write com.apple.Finder AppleShowAllFiles NO && killall Finder"
          alias clr='clear;echo "Currently logged in on $(tty), as $(whoami) in directory $(pwd)."'
          alias pypath='python -c "import sys; print sys.path" | tr "," "\n" | grep -v "egg"'

          # https://justin.abrah.ms/dotfiles/zsh.html
          extract_file () {
              if [ -f $1 ] ; then
                  case $1 in
                      *.tar.bz2)        tar xjf $1        ;;
                      *.tar.gz)         tar xzf $1        ;;
                      *.bz2)            bunzip2 $1        ;;
                      *.rar)            unrar x $1        ;;
                      *.gz)             gunzip $1         ;;
                      *.tar)            tar xf $1         ;;
                      *.tar.xz)         tar xf $1         ;;
                      *.tbz2)           tar xjf $1        ;;
                      *.tgz)            tar xzf $1        ;;
                      *.zip)            unzip $1          ;;
                      *.Z)              uncompress $1     ;;
                      *.7z)             7zr e $1          ;;
                      *)                echo "'$1' cannot be extracted via extract()" ;;
                  esac
              else
                  echo "'$1' is not a valid file"
              fi
          }

          # https://justin.abrah.ms/dotfiles/zsh.html
          dls () {
              # directory LS
              echo `ls -l | grep "^d" | awk '{ print $9 }' | tr -d "/"`
          }
          dgrep() {
              # A recursive, case-insensitive grep that excludes binary files
              grep -iR "$@" * | grep -v "Binary"
          }
          dfgrep() {
              # A recursive, case-insensitive grep that excludes binary files
              # and returns only unique filenames
              grep -iR "$@" * | grep -v "Binary" | sed 's/:/ /g' | awk '{ print $1 }' | sort | uniq
          }
          # psgrep() {
          #     if [ ! -z $1 ] ; then
          #         echo "Grepping for processes matching $1..."
          #         ps aux | grep $1 | grep -v grep
          #     else
          #         echo "!! Need name to grep for"
          #     fi
          # }

          exip () {
              # gather external ip address
              echo -n "Current External IP: "
              curl -s -m 5 http://myip.dk | grep "ha4" | sed -e 's/.*ha4">//g' -e 's/<\/span>.*//g'
          }

          # ips () {
          #     # determine local IP address
          #     ifconfig | grep "inet " | awk '{ print $2 }'
          # }

          # https://stackoverflow.com/questions/6918057/shell-list-directories-ordered-by-file-count-including-in-subdirectories
          countFiles () {
              # call the recursive function, throw away stdout and send stderr to stdout
              # then sort numerically
              countFiles_rec "$1" 2>&1 >/dev/null | sort -nr
          }

          countFiles_rec () {
              local -i nfiles
              dir="$1"

              # count the number of files in this directory only
              nfiles=$(find "$dir" -mindepth 1 -maxdepth 1 -type f -print | wc -l)

              # loop over the subdirectories of this directory
              while IFS= read -r subdir; do

                  # invoke the recursive function for each one
                  # save the output in the positional parameters
                  set -- $(countFiles_rec "$subdir")

                  # accumulate the number of files found under the subdirectory
                  (( nfiles += $1 ))

              done < <(find "$dir" -mindepth 1 -maxdepth 1 -type d -print)

              # print the number of files here, to both stdout and stderr
              printf "%d %s\n" $nfiles "$dir" | tee /dev/stderr
          }


          # countFiles Home

          sort_by_num_files () {

              find . -xdev -type f | cut -d "/" -f 2 | sort | uniq -c | sort -n

          }


          cd_to_cloud () {
              cd '/Volumes/Macintosh HD/Users/malcolm/Library/Mobile Documents/com~apple~CloudDocs/'
          }

          alias cd_cloud=cd_to_cloud

          cd_to_to_schedule_on_professorex() {
              pyenv activate ffmpeg-tools3 || true
              cd ~/Downloads/to_schedule_on_professorex
          }

          cd_to_albums() {
              pyenv activate ffmpeg-tools3 || true
              cd ~/Downloads/to_schedule_on_professorex/albums
          }

          cd_to_waiting_on_audio() {
              pyenv activate ffmpeg-tools3 || true
              cd ~/Downloads/to_schedule_on_professorex/waiting_on_audio

          }

          cd_to_meme_show_staging_area() {
              pyenv activate ffmpeg-tools3 || true
              cd '/Volumes/Macintosh HD/Users/malcolm/Movies/Media/meme_show_staging_area'

          }

          cd_to_meme_show_archive() {
              pyenv activate ffmpeg-tools3 || true
              cd '/Volumes/Macintosh HD/Users/malcolm/Movies/Media/meme show archive'

          }

          story_to_square_post() {
              pyenv activate ffmpeg-tools3 || true
              ffmpeg-tools -c batch-crop-story,batch-eq-mp4,batch-loop -f "$(PWD)" -r
          }

          cd_to_to_schedule_on_professorex_staging() {
              pyenv activate ffmpeg-tools3 || true
              cd ~/Downloads/to_schedule_on_professorex/staging
          }


          mkdir_date(){
              mkdir -p $(date +%Y%m%d)/{RAW,staging,normalized,cropped,square,split,more,memelords,titlescreen,tiktoks,story,stories,opener,saved,hunnies,tiktoks} || true
              cd $(date +%Y%m%d)
              pwd
          }


          ####################################

          cd_to_to_schedule_on_professorex_today() {
              pyenv activate ffmpeg-tools3 || true
              cd ~/Downloads/to_schedule_on_professorex/$(date +%Y%m%d)
              pwd
          }

          cd_to_albums_today() {
              pyenv activate ffmpeg-tools3 || true
              cd ~/Downloads/to_schedule_on_professorex/albums/$(date +%Y%m%d)
              cd $(date +%Y%m%d) || mkdir_date
          }



          cd_to_meme_show_staging_area_today() {
              pyenv activate ffmpeg-tools3 || true
              cd '/Volumes/Macintosh HD/Users/malcolm/Movies/Media/meme_show_staging_area'
              cd $(date +%Y%m%d) || mkdir_date
          }

          cd_to_meme_show_archive_today() {
              pyenv activate ffmpeg-tools3 || true
              cd '/Volumes/Macintosh HD/Users/malcolm/Movies/Media/meme show archive'
              cd $(date +%Y%m%d) || mkdir_date

          }

          story_to_square_post_today() {
              pyenv activate ffmpeg-tools3 || true
              ffmpeg-tools -c prepare-from-story -f "$(PWD)" -r
          }

          cd_to_to_schedule_on_professorex_staging_today() {
              pyenv activate ffmpeg-tools3 || true
              cd ~/Downloads/to_schedule_on_professorex/staging
              cd $(date +%Y%m%d) || mkdir_date
          }

          # SOURCE: https://github.com/zaklaus/dotfiles/blob/1e957bd3c43ca30d8a274940a54aa86d9e15a89a/.zshrc
          alias cn='clear; neofetch'			    # cn:	    Clear and display neofetch
          mcd () { mkdir -p "$1" && cd "$1"; }        # mcd:          Makes new Dir and jumps inside
          # SOURCE: https://github.com/lazmond3/dotfiles-public-mac/blob/81fd93f99582d71206243c16095aecaf456d2c5e/config/aliases.bash
          alias killf="kill \$(ps aux | fzf -m | awk '{print \$2}')"


          alias mkdir_cd="mcd"

          prepare_story() {
              pyenv activate ffmpeg-tools3 || true
              ffmpeg-tools -c prepare-from-story -f "$(PWD)" -r
          }

          prepare_square() {
              pyenv activate ffmpeg-tools3 || true
              ffmpeg-tools -c prepare-from-square -f "$(PWD)" -r
          }

          dl_download() {
              pyenv activate ffmpeg-tools3 || true
              ffmpeg-tools -c gallery-dl -f "$(PWD)/download.txt" -r --metadata
          }

          dl_story() {
              pyenv activate ffmpeg-tools3 || true
              ffmpeg-tools -c dl-story --user "${1}"
          }

          dl_all() {
              pyenv activate ffmpeg-tools3 || true
              ffmpeg-tools -c gallery-dl -f "$(PWD)/download.txt" -r --range '0-100' --metadata
              sleep $((1 + $RANDOM % 10))
              ffmpeg-tools -c gallery-dl -f "$(PWD)/download.txt" -r --range '101-200' --metadata
              sleep $((1 + $RANDOM % 10))
              ffmpeg-tools -c gallery-dl -f "$(PWD)/download.txt" -r --range '201-300' --metadata
              sleep $((1 + $RANDOM % 10))
              ffmpeg-tools -c gallery-dl -f "$(PWD)/download.txt" -r --range '301-400' --metadata
              sleep $((1 + $RANDOM % 10))
              ffmpeg-tools -c gallery-dl -f "$(PWD)/download.txt" -r --range '401-500' --metadata
              sleep $((1 + $RANDOM % 10))
              ffmpeg-tools -c gallery-dl -f "$(PWD)/download.txt" -r --range '501-600' --metadata
              sleep $((1 + $RANDOM % 10))
              ffmpeg-tools -c gallery-dl -f "$(PWD)/download.txt" -r --range '601-700' --metadata
              sleep $((1 + $RANDOM % 10))
              ffmpeg-tools -c gallery-dl -f "$(PWD)/download.txt" -r --range '701-800' --metadata
              echo -e " [run] countFiles $(PWD)\n"
              countFiles "$(PWD)"
          }


      - name: unzip.zsh
        content: |
          # darktop config (8/10/2020)
          export PATH="$( brew --prefix unzip)/bin:$PATH"

          unzip_nuke() {
            unzip \*.zip && rm *.zip
          }

      - name: imagemagick.zsh
        content: |
          imagemagick_white_jpg(){
              # create white background first
              convert -size 1080x1080 xc:white white.jpg
          }

          imagemagick_resize_square_batch() {
              imagemagick_white_jpg
              rm -fv loop.txt
              touch loop.txt
              OIFS="$IFS"
              IFS=$'\n'
              for file in `find . -maxdepth 1 -mindepth 1 -type f -name "*.png"`
              do
                  echo "file = $file"
                  echo imagemagick_resize_square "$file" >> loop.txt
              done
              for file in `find . -maxdepth 1 -mindepth 1 -type f -name "*.jpg"`
              do
                  echo "file = $file"
                  echo imagemagick_resize_square "$file" >> loop.txt
              done
              for file in `find . -maxdepth 1 -mindepth 1 -type f -name "*.jpeg"`
              do
                  echo "file = $file"
                  echo imagemagick_resize_square "$file" >> loop.txt
              done
              for file in `find . -maxdepth 1 -mindepth 1 -type f -name "*.JPG"`
              do
                  echo "file = $file"
                  echo imagemagick_resize_square "$file" >> loop.txt
              done
              for file in `find . -maxdepth 1 -mindepth 1 -type f -name "*.JPEG"`
              do
                  echo "file = $file"
                  echo imagemagick_resize_square "$file" >> loop.txt
              done

              cat loop.txt
              gsed -i "s,\.\/,'\.\/,g" loop.txt
              gsed -i "s,$,',g" loop.txt
              sort -ru loop.txt > loop.sh
              cat loop.sh
              bash loop.sh
              rm loop.sh
              rm loop.txt
              ls -lta
              IFS="$OIFS"
          }


          imagemagick_jpg_to_png(){
              mogrify -format png *.JPG
              mogrify -format png *.JPEG
              mogrify -format png *.jpg
              mogrify -format png *.jpeg
              mkdir pngs || true
              mv -fv *.png pngs/
          }



      - name: ffmpegutils.zsh
        content: |
          function crop_yt_tiktoks() {
              local _input=$(basename -- "${1}" | cut -d"." -f1)
              local get_extension=$(basename -- $1 | cut -d"." -f2)
              local _input_fname="${_input}.${get_extension}"
              local _out_fname="${_input}_out.${get_extension}"

              echo "_input = $_input"
              echo "get_extension = $get_extension"
              echo "_input_fname = $_input_fname"
              echo "_out_fname = $_out_fname"

              echo "ffmpeg -y -i \"${_input_fname}\" -filter:v \"crop=403:720:441:436:keep_aspect=1\" -c:a copy \"${_out_fname}\""

              ffmpeg -y -i "${_input_fname}" -filter:v "crop=403:720:441:436:keep_aspect=1" -c:a copy "${_out_fname}"
          }


          # https://gist.github.com/jonsuh/3c89c004888dfc7352be
          # ----------------------------------
          # Colors
          # ----------------------------------
          export NOCOLOR='\033[0m'
          export RED='\033[0;31m'
          export GREEN='\033[0;32m'
          export ORANGE='\033[0;33m'
          export BLUE='\033[0;34m'
          export MAD_BLUE='\e[34m'
          export PURPLE='\033[0;35m'
          export CYAN='\033[0;36m'
          export LIGHTGRAY='\033[0;37m'
          export DARKGRAY='\033[1;30m'
          export LIGHTRED='\033[1;31m'
          export LIGHTGREEN='\033[1;32m'
          export YELLOW='\033[1;33m'
          export LIGHTBLUE='\033[1;34m'
          export LIGHTPURPLE='\033[1;35m'
          export LIGHTCYAN='\033[1;36m'
          export WHITE='\033[1;37m'

          get_loop_commands() {
              rm loop.txt || true
              for filename in ./*.mp4; do echo ffmpeg-loop \"$filename\"; done > loop.txt
              cat loop.txt
          }

          ffmpeg-generate-ig-square() {
              rm -fv square.txt
              touch square.txt
              [ "$(ls *.jpg | tr " " '\r' | wc -l | awk '{print $1}')" -gt "0" ] && for filename in ./*jpg*; do echo ffmpeg -hide_banner -loglevel warning -i "$filename" -vf "scale=1080:1080:force_original_aspect_ratio=decrease,pad=1080:1080:-1:-1:color=white,setdar=1:1" "ig-square-1080x1080-$(basename -- "${filename}")"; done >> square.txt
              [ "$(ls *.jpeg | tr " " '\r' | wc -l | awk '{print $1}')" -gt "0" ] && for filename in ./*jpeg*; do echo ffmpeg -hide_banner -loglevel warning -i "$filename" -vf "scale=1080:1080:force_original_aspect_ratio=decrease,pad=1080:1080:-1:-1:color=white,setdar=1:1" "ig-square-1080x1080-$(basename -- "${filename}")"; done >> square.txt
              [ "$(ls *.png | tr " " '\r' | wc -l | awk '{print $1}')" -gt "0" ] && for filename in ./*png*; do echo ffmpeg -hide_banner -loglevel warning -i "$filename" -vf "scale=1080:1080:force_original_aspect_ratio=decrease,pad=1080:1080:-1:-1:color=white,setdar=1:1" "ig-square-1080x1080-$(basename -- "${filename}")"; done >> square.txt
              cat square.txt
              bash square.txt
              rm square.txt
          }

          ffmpeg-square-mp4() {
              OIFS="$IFS"
              IFS=$'\n'
              rm -fv square.txt
              touch square.txt
              [ "$(ls *.mp4 | tr " " '\r' | wc -l | awk '{print $1}')" -gt "0" ] && for filename in ./*mp4*; do echo ffmpeg -hide_banner -loglevel warning -i "${filename}" -vf "scale=1080:1080:force_original_aspect_ratio=decrease,pad=1080:1080:-1:-1:color=white,setdar=1:1" "ig-square-1080x1080-$(basename -- "${filename}")"; done >> square.txt
              cat square.txt
              bash square.txt
              rm square.txt
              IFS="$OIFS"
          }
          # $(PWD)/

          ffmpeg-crop-story-batch() {
              OIFS="$IFS"
              IFS=$'\n'
              rm -fv story.txt
              touch story.txt
              [ "$(ls *.mp4 | tr " " '\r' | wc -l | awk '{print $1}')" -gt "0" ] && for filename in ./*mp4*; do echo ffmpeg-crop-story "${filename}"; done >> story.txt
              cat story.txt
              bash story.txt
              rm story.txt
              IFS="$OIFS"
          }
          # $(PWD)/

          ffmpeg-mov-to-mp4() {
              OIFS="$IFS"
              IFS=$'\n'
              rm -fv square.txt || true
              touch square.txt
              current_dir=$(PWD)

              [ "$(ls *.MOV | tr " " '\r' | wc -l | awk '{print $1}')" -gt "0" ] && for filename in ./*MOV*; do echo ffmpeg-mov-to-mp4 $(python3 -c "import pathlib;p=pathlib.Path('${filename}');print(p)"); done >> square.txt
              [ "$(ls *.mov | tr " " '\r' | wc -l | awk '{print $1}')" -gt "0" ] && for filename in ./*mov*; do echo ffmpeg-mov-to-mp4 $(python3 -c "import pathlib;p=pathlib.Path('${filename}');print(p)"); done >> square.txt
              cat square.txt
              # bash square.txt
              rm square.txt || true
              IFS="$OIFS"
          }
          # $(PWD)/

          ffmpeg-dimensions-mp4() {
              rm -fv loop.txt
              touch loop.txt
              # rm -fv dimensions.txt
              # touch dimensions.txt

              OIFS="$IFS"
              IFS=$'\n'
              for file in `find . -maxdepth 1 -mindepth 1 -type f -name "*.mp4"`
              do
                  echo "file = $file"
                  echo ffmpeg-dimensions -f "$file" >> loop.txt
              done

              cat loop.txt
              gsed -i "s,\.\/,'\.\/,g" loop.txt
              gsed -i "s,$,',g" loop.txt
              cat loop.txt
              bash loop.txt >> dimensions_info.txt
              rm loop.txt
              sort -ru dimensions_info.txt > dimensions.txt
              # rm dimensions_info.txt || true
              cat dimensions.txt
              IFS="$OIFS"

          }

          ffmpeg-dimensions-jpeg() {
              rm -fv loop.txt
              touch loop.txt
              # rm -fv dimensions.txt
              # touch dimensions.txt

              OIFS="$IFS"
              IFS=$'\n'
              for file in `find . -maxdepth 1 -mindepth 1 -type f -name "*.JPEG|*.jpeg|*.JPG|*.jpg"`
              do
                  echo "file = $file"
                  echo ffmpeg-dimensions -f "$file" >> loop.txt
              done

              cat loop.txt
              gsed -i "s,\.\/,'\.\/,g" loop.txt
              gsed -i "s,$,',g" loop.txt
              cat loop.txt
              bash loop.txt >> dimensions_info.txt
              rm loop.txt
              sort -ru dimensions_info.txt > dimensions.txt
              # rm dimensions_info.txt || true
              cat dimensions.txt
              IFS="$OIFS"
          }

          ffmpeg-dimensions-png() {
              rm -fv loop.txt
              touch loop.txt
              # rm -fv dimensions.txt
              # touch dimensions.txt

              OIFS="$IFS"
              IFS=$'\n'
              for file in `find . -maxdepth 1 -mindepth 1 -type f -name "*.png"`
              do
                  echo "file = $file"
                  echo ffmpeg-dimensions -f "$file" >> loop.txt
              done

              cat loop.txt
              gsed -i "s,\.\/,'\.\/,g" loop.txt
              gsed -i "s,$,',g" loop.txt
              cat loop.txt
              bash loop.txt >> dimensions_info.txt
              rm loop.txt
              sort -ru dimensions_info.txt > dimensions.txt
              # rm dimensions_info.txt || true
              cat dimensions.txt
              IFS="$OIFS"
          }

          ffmpeg-dimensions-mov() {
              rm -fv loop.txt
              touch loop.txt
              # rm -fv dimensions.txt
              # touch dimensions.txt

              OIFS="$IFS"
              IFS=$'\n'
              for file in `find . -maxdepth 1 -mindepth 1 -type f -name "*.MOV|*.mov"`
              do
                  echo "file = $file"
                  echo ffmpeg-dimensions -f "$file" >> loop.txt
              done

              cat loop.txt
              gsed -i "s,\.\/,'\.\/,g" loop.txt
              gsed -i "s,$,',g" loop.txt
              cat loop.txt
              bash loop.txt >> dimensions_info.txt
              rm loop.txt
              sort -ru dimensions_info.txt > dimensions.txt
              # rm dimensions_info.txt || true
              cat dimensions.txt
              IFS="$OIFS"
          }

          ffmpeg-loop-batch() {
              OIFS="$IFS"
              IFS=$'\n'
              rm -fv loop.txt
              touch loop.txt
              [ "$(ls *.mp4 | tr " " '\r' | wc -l | awk '{print $1}')" -gt "0" ] && for filename in ./*mp4*; do echo ffmpeg-loop-one "${filename}"; done >> loop.txt
              cat loop.txt
              bash loop.txt
              rm loop.txt
              IFS="$OIFS"
          }


          ffmpeg-dimensions-all() {
              rm all-dimensions.txt || true
              ffmpeg-dimensions-mp4 >> all-dimensions.txt
              ffmpeg-dimensions-jpeg >> all-dimensions.txt
              ffmpeg-dimensions-png >> all-dimensions.txt
              ffmpeg-dimensions-mov >> all-dimensions.txt
              grep -v "ffmpeg-dimensions" all-dimensions.txt >> temp.txt
              grep -v "file = ./" all-dimensions.txt >> temp.txt
              sort -ru temp.txt > all-dimensions.txt
              echo -e "\n\n ${GREEN}ffmpeg-dimensions-all]${NOCOLOR} ${CYAN}cat all-dimensions.txt${NOCOLOR}\n\n"
              cat all-dimensions.txt
          }

          function crop_yt_tiktoks() {
              local _input=$(basename -- "${1}" | cut -d"." -f1)
              local get_extension=$(basename -- $1 | cut -d"." -f2)
              local _input_fname="${_input}.${get_extension}"
              local _out_fname="${_input}_out.${get_extension}"

              echo "_input = $_input"
              echo "get_extension = $get_extension"
              echo "_input_fname = $_input_fname"
              echo "_out_fname = $_out_fname"

              echo "ffmpeg -y -i \"${_input_fname}\" -filter:v \"crop=403:720:441:436\" -c:a copy \"${_out_fname}\""

              ffmpeg -y -i "${_input_fname}" -filter:v "crop=403:720:441:436" -c:a copy "${_out_fname}"
          }

          # https://stackoverflow.com/questions/7333232/how-to-concatenate-two-mp4-files-using-ffmpeg
          # $ cat mylist.txt
          # file '/path/to/file1'
          # file '/path/to/file2'
          # file '/path/to/file3'

          # $ ffmpeg -f concat -safe 0 -i mylist.txt -c copy output.mp4



      - name: pyenv.zsh
        content: |-



          _ARCH=$(uname -m)
          if [[ "${_ARCH}" = "arm64" ]]; then
              _MY_OPT_HOMEBREW=/opt/homebrew
          else
              _MY_OPT_HOMEBREW=/usr/local
          fi

          local OPT_HOMEBREW="${_MY_OPT_HOMEBREW}"
          # local OPT_HOMEBREW="/opt/homebrew"
          if [[ -s "$OPT_HOMEBREW"/bin/brew ]]; then
              eval "$($OPT_HOMEBREW/bin/brew shellenv)"
          fi

          if [[ -s "$HOMEBREW_PREFIX"/opt/pyenv/libexec/pyenv ]]; then
            eval "$(${HOMEBREW_PREFIX}/opt/pyenv/libexec/pyenv init --path)"
            eval "$(${HOMEBREW_PREFIX}/opt/pyenv/libexec/pyenv init -)"
            fpath=(${HOMEBREW_PREFIX}/opt/pyenv/completions $fpath)
            pyenv virtualenvwrapper_lazy

          elif [[ -s "$HOME/.pyenv/bin/pyenv" ]]; then
            export PYENV_ROOT=~/.pyenv
            export PATH="$PYENV_ROOT/bin:$PATH"
            eval "$(pyenv init --path)"
            eval "$(pyenv init -)"
            pyenv virtualenvwrapper_lazy
          fi

          enable_compile_flags() {
            # SOURCE: https://github.com/jiansoung/issues-list/issues/13
            # Fixes: zipimport.ZipImportError: can't decompress data; zlib not available
            export LOCAL_HOMEBREW_PREFIX="$(brew --prefix)"
            export PATH="${LOCAL_HOMEBREW_PREFIX}/opt/tcl-tk/bin:$PATH"
            export PATH="${LOCAL_HOMEBREW_PREFIX}/opt/bzip2/bin:$PATH"
            export PATH="${LOCAL_HOMEBREW_PREFIX}/opt/ncurses/bin:$PATH"
            export PATH="${LOCAL_HOMEBREW_PREFIX}/opt/openssl@1.1/bin:$PATH"
            # SOURCE: https://github.com/jiansoung/issues-list/issues/13
            # Fixes: zipimport.ZipImportError: can't decompress data; zlib not available
            export CFLAGS="${CFLAGS} -I$(brew --prefix tcl-tk)/include"
            export LDFLAGS="${LDFLAGS} -L${LOCAL_HOMEBREW_PREFIX}/opt/tcl-tk/lib"
            export CPPFLAGS="${CPPFLAGS} -I${LOCAL_HOMEBREW_PREFIX}/opt/tcl-tk/include"
            export LDFLAGS="${LDFLAGS} -L${LOCAL_HOMEBREW_PREFIX}/opt/zlib/lib"
            export CPPFLAGS="${CPPFLAGS} -I${LOCAL_HOMEBREW_PREFIX}/opt/zlib/include"
            export LDFLAGS="${LDFLAGS} -L${LOCAL_HOMEBREW_PREFIX}/opt/sqlite/lib"
            export CPPFLAGS="${CPPFLAGS} -I${LOCAL_HOMEBREW_PREFIX}/opt/sqlite/include"
            export LDFLAGS="${LDFLAGS} -L${LOCAL_HOMEBREW_PREFIX}/opt/libffi/lib"
            export CPPFLAGS="${CPPFLAGS} -I${LOCAL_HOMEBREW_PREFIX}/opt/libffi/include"
            export LDFLAGS="${LDFLAGS} -L${LOCAL_HOMEBREW_PREFIX}/opt/bzip2/lib"
            export CPPFLAGS="${CPPFLAGS} -I${LOCAL_HOMEBREW_PREFIX}/opt/bzip2/include"
            export LDFLAGS="${LDFLAGS} -L${LOCAL_HOMEBREW_PREFIX}/opt/ncurses/lib"
            export CPPFLAGS="${CPPFLAGS} -I${LOCAL_HOMEBREW_PREFIX}/opt/ncurses/include"
            export LDFLAGS="${LDFLAGS} -L${LOCAL_HOMEBREW_PREFIX}/opt/openssl@1.1/lib"
            export CPPFLAGS="${CPPFLAGS} -I${LOCAL_HOMEBREW_PREFIX}/opt/openssl@1.1/include"
            export PKG_CONFIG_PATH="${PKG_CONFIG_PATH} ${LOCAL_HOMEBREW_PREFIX}/opt/zlib/lib/pkgconfig"
            export PKG_CONFIG_PATH="${PKG_CONFIG_PATH} ${LOCAL_HOMEBREW_PREFIX}/opt/sqlite/lib/pkgconfig"
            export PKG_CONFIG_PATH="${PKG_CONFIG_PATH} ${LOCAL_HOMEBREW_PREFIX}/opt/tcl-tk/lib/pkgconfig"
            export PKG_CONFIG_PATH="${PKG_CONFIG_PATH} ${LOCAL_HOMEBREW_PREFIX}/opt/libffi/lib/pkgconfig"
            export PKG_CONFIG_PATH="${PKG_CONFIG_PATH} ${LOCAL_HOMEBREW_PREFIX}/opt/ncurses/lib/pkgconfig"
            export PKG_CONFIG_PATH="${PKG_CONFIG_PATH} ${LOCAL_HOMEBREW_PREFIX}/opt/openssl@1.1/lib/pkgconfig"
            export PYTHON_CONFIGURE_OPTS="--with-tcltk-includes='-I$(brew --prefix tcl-tk)/include' --with-tcltk-libs='-L$(brew --prefix tcl-tk)/lib -ltcl8.6 -ltk8.6'"
            export PROFILE_TASK='-m test.regrtest --pgo \
                  test_array \
                  test_base64 \
                  test_binascii \
                  test_binhex \
                  test_binop \
                  test_bytes \
                  test_c_locale_coercion \
                  test_class \
                  test_cmath \
                  test_codecs \
                  test_compile \
                  test_complex \
                  test_csv \
                  test_decimal \
                  test_dict \
                  test_float \
                  test_fstring \
                  test_hashlib \
                  test_io \
                  test_iter \
                  test_json \
                  test_long \
                  test_math \
                  test_memoryview \
                  test_pickle \
                  test_re \
                  test_set \
                  test_slice \
                  test_struct \
                  test_threading \
                  test_time \
                  test_traceback \
                  test_unicode \
            '
          }

          print_compile_flags() {
            enable_compile_flags

            echo "----------------------"
            echo "Verify pyenv compile env vars"
            echo "----------------------"
            echo "LDFLAGS: ${LDFLAGS}"
            echo "CPPFLAGS: ${CPPFLAGS}"
            echo "PKG_CONFIG_PATH: ${PKG_CONFIG_PATH}"
            echo "PYTHON VERSION TO COMPILE: ${_PY_VER_MAJOR}.${_PY_VER_MINOR}.${_PY_VER_MICRO}"
            echo "----------------------"
          }

          verify_keg_folders_exists() {
            stat "$(brew --prefix)/opt/tcl-tk/lib" && \
            stat "$(brew --prefix)/opt/zlib/lib" && \
            stat "$(brew --prefix)/opt/sqlite/lib" && \
            stat "$(brew --prefix)/opt/libffi/lib" && \
            stat "$(brew --prefix)/opt/bzip2/lib" && \
            stat "$(brew --prefix)/opt/ncurses/lib" && \
            stat "$(brew --prefix)/opt/openssl@1.1/lib" && \
            stat "$(brew --prefix)/opt/tcl-tk/include" && \
            stat "$(brew --prefix)/opt/zlib/include" && \
            stat "$(brew --prefix)/opt/sqlite/include" && \
            stat "$(brew --prefix)/opt/libffi/include" && \
            stat "$(brew --prefix)/opt/bzip2/include" && \
            stat "$(brew --prefix)/opt/ncurses/include" && \
            stat "$(brew --prefix)/opt/openssl@1.1/include" && \
            stat "$(brew --prefix)/opt/zlib/lib/pkgconfig" && \
            stat "$(brew --prefix)/opt/sqlite/lib/pkgconfig" && \
            stat "$(brew --prefix)/opt/tcl-tk/lib/pkgconfig" && \
            stat "$(brew --prefix)/opt/libffi/lib/pkgconfig" && \
            stat "$(brew --prefix)/opt/ncurses/lib/pkgconfig" && \
            stat "$(brew --prefix)/opt/openssl@1.1/lib/pkgconfig"

          }

          function compile_python() {
              if [ ! -d "${PYENV_ROOT}/versions/${_PY_VER_MAJOR}.${_PY_VER_MINOR}.${_PY_VER_MICRO}" ]; then
              # Control will enter here if $DIRECTORY exists.
              env PYTHON_CONFIGURE_OPTS="--enable-shared --enable-optimizations --enable-ipv6 --with-dtrace --enable-loadable-sqlite-extensions --with-openssl=${LOCAL_HOMEBREW_PREFIX}/opt/openssl@1.1" pyenv install -v ${_PY_VER_MAJOR}.${_PY_VER_MINOR}.${_PY_VER_MICRO}
              else
              echo " [python-compile](compile_python) python version ${_PY_VER_MAJOR}.${_PY_VER_MINOR}.${_PY_VER_MICRO} already installed, skipping"
              fi
          }

          python_interperter(){
            python3 -c "import sys;print(sys.executable)"
          }


          opencv-deps() {
            pip install scipy pillow
            pip install imutils h5py requests progressbar2
            pip install scikit-learn scikit-image
            pip install matplotlib
            mkdir ~/.matplotlib
            touch ~/.matplotlib/matplotlibrc
            echo "backend: TkAgg" >> ~/.matplotlib/matplotlibrc
            pip install tensorflow
            pip install keras
            python -c "import keras;"
            pip install scenedetect[opencv]
          }


      - name: 1pass.zsh
        content: |
          enable_op_cli(){
            # 1pass
            if [ -f /usr/local/bin/op ]; then
                eval $(op signin my)
                eval "$(op completion zsh)"; compdef _op op
            fi
          }

          get_all_secret_dotfiles(){

            op get document ".secret.vault" --output ~/.secret.vault
            chmod 0600 ~/.secret.vault

            op get document "~/.zsh.d/after/cv.zsh" --output ~/.zsh.d/after/cv.zsh || ls -lta ~/.zsh.d/after/cv.zsh
            op get document "~/.zsh.d/after/ffmpeg.zsh" --output ~/.zsh.d/after/ffmpeg.zsh || ls -lta ~/.zsh.d/after/ffmpeg.zsh
            op get document "~/.zsh.d/after/adobe.zsh" --output ~/.zsh.d/after/adobe.zsh || ls -lta ~/.zsh.d/after/adobe.zsh

          }

      - name: updatedb.zsh
        content: |
          # updatedb () {

          #     sudo /usr/libexec/locate.updatedb

          # }

      - name: ffmpeg.zsh
        content: |
          # https://gist.github.com/jonsuh/3c89c004888dfc7352be
          # ----------------------------------
          # Colors
          # ----------------------------------
          export NOCOLOR='\033[0m'
          export RED='\033[0;31m'
          export GREEN='\033[0;32m'
          export ORANGE='\033[0;33m'
          export BLUE='\033[0;34m'
          export MAD_BLUE='\e[34m'
          export PURPLE='\033[0;35m'
          export CYAN='\033[0;36m'
          export LIGHTGRAY='\033[0;37m'
          export DARKGRAY='\033[1;30m'
          export LIGHTRED='\033[1;31m'
          export LIGHTGREEN='\033[1;32m'
          export YELLOW='\033[1;33m'
          export LIGHTBLUE='\033[1;34m'
          export LIGHTPURPLE='\033[1;35m'
          export LIGHTCYAN='\033[1;36m'
          export WHITE='\033[1;37m'

          get_loop_commands() {
              rm loop.txt || true
              for filename in ./*.mp4; do echo ffmpeg-loop \"$filename\"; done > loop.txt
              cat loop.txt
          }

          ffmpeg-generate-ig-square() {
              rm -fv square.txt
              touch square.txt
              [ "$(ls *.jpg | tr " " '\r' | wc -l | awk '{print $1}')" -gt "0" ] && for filename in ./*jpg*; do echo ffmpeg -hide_banner -loglevel warning -i "$filename" -vf "scale=1080:1080:force_original_aspect_ratio=decrease,pad=1080:1080:-1:-1:color=white,setdar=1:1" "ig-square-1080x1080-$(basename -- "${filename}")"; done >> square.txt
              [ "$(ls *.jpeg | tr " " '\r' | wc -l | awk '{print $1}')" -gt "0" ] && for filename in ./*jpeg*; do echo ffmpeg -hide_banner -loglevel warning -i "$filename" -vf "scale=1080:1080:force_original_aspect_ratio=decrease,pad=1080:1080:-1:-1:color=white,setdar=1:1" "ig-square-1080x1080-$(basename -- "${filename}")"; done >> square.txt
              [ "$(ls *.png | tr " " '\r' | wc -l | awk '{print $1}')" -gt "0" ] && for filename in ./*png*; do echo ffmpeg -hide_banner -loglevel warning -i "$filename" -vf "scale=1080:1080:force_original_aspect_ratio=decrease,pad=1080:1080:-1:-1:color=white,setdar=1:1" "ig-square-1080x1080-$(basename -- "${filename}")"; done >> square.txt
              cat square.txt
              bash square.txt
              rm square.txt
          }

          ffmpeg-square-mp4() {
              OIFS="$IFS"
              IFS=$'\n'
              rm -fv square.txt
              touch square.txt
              [ "$(ls *.mp4 | tr " " '\r' | wc -l | awk '{print $1}')" -gt "0" ] && for filename in ./*mp4*; do echo ffmpeg -hide_banner -loglevel warning -i "${filename}" -vf "scale=1080:1080:force_original_aspect_ratio=decrease,pad=1080:1080:-1:-1:color=white,setdar=1:1" "ig-square-1080x1080-$(basename -- "${filename}")"; done >> square.txt
              cat square.txt
              bash square.txt
              rm square.txt
              IFS="$OIFS"
          }
          # $(PWD)/

          ffmpeg-crop-story-batch() {
              OIFS="$IFS"
              IFS=$'\n'
              rm -fv story.txt
              touch story.txt
              [ "$(ls *.mp4 | tr " " '\r' | wc -l | awk '{print $1}')" -gt "0" ] && for filename in ./*mp4*; do echo ffmpeg-crop-story "${filename}"; done >> story.txt
              cat story.txt
              bash story.txt
              rm story.txt
              IFS="$OIFS"
          }
          # $(PWD)/

          ffmpeg-mov-to-mp4-batch() {
              OIFS="$IFS"
              IFS=$'\n'
              rm -fv square.txt || true
              touch square.txt
              current_dir=$(PWD)

              [ "$(ls *.MOV | tr " " '\r' | wc -l | awk '{print $1}')" -gt "0" ] && for filename in ./*MOV*; do echo ffmpeg-mov-to-mp4 $(python3 -c "import pathlib;p=pathlib.Path('${filename}');print(p)"); done >> square.txt
              [ "$(ls *.mov | tr " " '\r' | wc -l | awk '{print $1}')" -gt "0" ] && for filename in ./*mov*; do echo ffmpeg-mov-to-mp4 $(python3 -c "import pathlib;p=pathlib.Path('${filename}');print(p)"); done >> square.txt
              cat square.txt
              bash square.txt
              rm square.txt || true
              IFS="$OIFS"
          }
          # $(PWD)/

          ffmpeg-speed-up-batch() {
              OIFS="$IFS"
              IFS=$'\n'
              rm -fv square.txt || true
              touch square.txt
              current_dir=$(PWD)

              [ "$(ls *.mp4 | tr " " '\r' | wc -l | awk '{print $1}')" -gt "0" ] && for filename in ./*mp4*; do echo ffmpeg-speed-up -f $(python3 -c "import pathlib;p=pathlib.Path('${filename}');print(p)").mp4; done >> square.txt
              cat square.txt
              bash square.txt
              rm square.txt || true
              IFS="$OIFS"
          }
          # $(PWD)/

          ffmpeg-watermark-batch() {
              OIFS="$IFS"
              IFS=$'\n'
              rm -fv watermark.txt || true
              touch watermark.txt
              current_dir=$(PWD)
              [ "$(ls *.mp4 | tr " " '\r' | wc -l | awk '{print $1}')" -gt "0" ] && for filename in ./*mp4*; do echo ffmpeg-watermark -t "@iamprofessorex" -f $(python3 -c "import pathlib;p=pathlib.Path('${filename}');print(p)") -c $(python3 -c "import pathlib;p=pathlib.Path('${filename}');print(p)"); done >> watermark.txt
              cat watermark.txt
              bash watermark.txt
              rm watermark.txt || true
              IFS="$OIFS"
          }
          # $(PWD)/


          # ffmpeg -hide_banner -loglevel warning -i ./niggasbebrokeokayyy_118455172_302163674220191_6892308790624835230_n.jpg -vf scale=1080:1080:force_original_aspect_ratio=decrease,pad=1080:1080:-1:-1:color=white,setdar=1:1 drawtext=fontfile=/Volumes/Macintosh HD/System/Library/Fonts/Helvetica.ttc: text='@iamprofessorEX': fontcolor=white: fontsize=14: box=1: boxcolor=black@0.5: boxborderw=5: x=(w-text_w)-10: y=(h-text_h)-10 -c:a aac -q:a 128k ig-square-1080x1080-niggasbebrokeokayyy_118455172_302163674220191_6892308790624835230_n.jpg

          ffmpeg-dimensions-mp4() {
              rm -fv loop.txt
              touch loop.txt
              # rm -fv dimensions.txt
              # touch dimensions.txt

              OIFS="$IFS"
              IFS=$'\n'
              for file in `find . -maxdepth 1 -mindepth 1 -type f -name "*.mp4"`
              do
                  echo "file = $file"
                  echo ffmpeg-dimensions -f "$file" >> loop.txt
              done

              cat loop.txt
              gsed -i "s,\.\/,'\.\/,g" loop.txt
              gsed -i "s,$,',g" loop.txt
              cat loop.txt
              bash loop.txt >> dimensions_info.txt
              rm loop.txt
              sort -ru dimensions_info.txt > dimensions.txt
              # rm dimensions_info.txt || true
              cat dimensions.txt
              IFS="$OIFS"

          }

          ffmpeg-dimensions-jpeg() {
              rm -fv loop.txt
              touch loop.txt
              # rm -fv dimensions.txt
              # touch dimensions.txt

              OIFS="$IFS"
              IFS=$'\n'
              for file in `find . -maxdepth 1 -mindepth 1 -type f -name "*.JPEG|*.jpeg|*.JPG|*.jpg"`
              do
                  echo "file = $file"
                  echo ffmpeg-dimensions -f "$file" >> loop.txt
              done

              cat loop.txt
              gsed -i "s,\.\/,'\.\/,g" loop.txt
              gsed -i "s,$,',g" loop.txt
              cat loop.txt
              bash loop.txt >> dimensions_info.txt
              rm loop.txt
              sort -ru dimensions_info.txt > dimensions.txt
              # rm dimensions_info.txt || true
              cat dimensions.txt
              IFS="$OIFS"
          }

          ffmpeg-dimensions-png() {
              rm -fv loop.txt
              touch loop.txt
              # rm -fv dimensions.txt
              # touch dimensions.txt

              OIFS="$IFS"
              IFS=$'\n'
              for file in `find . -maxdepth 1 -mindepth 1 -type f -name "*.png"`
              do
                  echo "file = $file"
                  echo ffmpeg-dimensions -f "$file" >> loop.txt
              done

              cat loop.txt
              gsed -i "s,\.\/,'\.\/,g" loop.txt
              gsed -i "s,$,',g" loop.txt
              cat loop.txt
              bash loop.txt >> dimensions_info.txt
              rm loop.txt
              sort -ru dimensions_info.txt > dimensions.txt
              # rm dimensions_info.txt || true
              cat dimensions.txt
              IFS="$OIFS"
          }

          ffmpeg-dimensions-mov() {
              rm -fv loop.txt
              touch loop.txt
              # rm -fv dimensions.txt
              # touch dimensions.txt

              OIFS="$IFS"
              IFS=$'\n'
              for file in `find . -maxdepth 1 -mindepth 1 -type f -name "*.MOV|*.mov"`
              do
                  echo "file = $file"
                  echo ffmpeg-dimensions -f "$file" >> loop.txt
              done

              cat loop.txt
              gsed -i "s,\.\/,'\.\/,g" loop.txt
              gsed -i "s,$,',g" loop.txt
              cat loop.txt
              bash loop.txt >> dimensions_info.txt
              rm loop.txt
              sort -ru dimensions_info.txt > dimensions.txt
              # rm dimensions_info.txt || true
              cat dimensions.txt
              IFS="$OIFS"
          }

          ffmpeg-loop-batch() {
              OIFS="$IFS"
              IFS=$'\n'
              rm -fv loop.txt
              touch loop.txt
              [ "$(ls *.mp4 | tr " " '\r' | wc -l | awk '{print $1}')" -gt "0" ] && for filename in ./*mp4*; do echo ffmpeg-loop-one "${filename}"; done >> loop.txt
              cat loop.txt
              bash loop.txt
              rm loop.txt
              IFS="$OIFS"
          }


          ffmpeg-dimensions-all() {
              rm all-dimensions.txt || true
              ffmpeg-dimensions-mp4 >> all-dimensions.txt
              ffmpeg-dimensions-jpeg >> all-dimensions.txt
              ffmpeg-dimensions-png >> all-dimensions.txt
              ffmpeg-dimensions-mov >> all-dimensions.txt
              grep -v "ffmpeg-dimensions" all-dimensions.txt >> temp.txt
              grep -v "file = ./" all-dimensions.txt >> temp.txt
              sort -ru temp.txt > all-dimensions.txt
              echo -e "\n\n ${GREEN}ffmpeg-dimensions-all]${NOCOLOR} ${CYAN}cat all-dimensions.txt${NOCOLOR}\n\n"
              cat all-dimensions.txt
          }

          function crop_yt_tiktoks() {
              local _input=$(basename -- "${1}" | cut -d"." -f1)
              local get_extension=$(basename -- $1 | cut -d"." -f2)
              local _input_fname="${_input}.${get_extension}"
              local _out_fname="${_input}_out.${get_extension}"

              echo "_input = $_input"
              echo "get_extension = $get_extension"
              echo "_input_fname = $_input_fname"
              echo "_out_fname = $_out_fname"

              echo "ffmpeg -y -i \"${_input_fname}\" -filter:v \"crop=403:720:441:436\" -c:a copy \"${_out_fname}\""

              ffmpeg -y -i "${_input_fname}" -filter:v "crop=403:720:441:436" -c:a copy "${_out_fname}"
          }

          # https://stackoverflow.com/questions/7333232/how-to-concatenate-two-mp4-files-using-ffmpeg
          # $ cat mylist.txt
          # file '/path/to/file1'
          # file '/path/to/file2'
          # file '/path/to/file3'

          # $ ffmpeg -f concat -safe 0 -i mylist.txt -c copy output.mp4

          ffmpeg_prepare_for_ig_pipeline(){
              # resize all mp4s to 1080x1080
              ffmpeg-square-mp4;
              # resize all images to 1080x1080
              imagemagick_resize_square_batch;
              # convert all jpeg to png ( required to add music )
              imagemagick_jpg_to_png;
              # move everything
              mkdir squared|| true;
              mv *square* squared;
              mv *out.* squared
              # ffmpeg-loop-batch
          }


          ffmpeg_stitch_all(){
              for f in *.mp4 ; do echo file \'$f\' >> list.txt; done && ffmpeg -f concat -safe 0 -i list.txt -c copy stitched-video.mp4 && rm list.txt
          }


          ffmpeg_loop() {
              f="$(basename -- ${1})"
              local fname="$(PWD)/${f}"
              echo " [running] ffmpeg-tools -c loop -f \"${fname}\" -r"
              ffmpeg-tools -c loop -f "${fname}" -r
          }

      - name: cv.zsh
        content: |
          redo_pyscenedetect_all(){
              pyenv activate cv3 || true
              echo '#!/usr/bin/env bash' > redo.sh
              [ "$(ls *.mp4 | tr " " '\r' | wc -l | awk '{print $1}')" -gt "0" ] && for filename in ./*mp4*; do echo scenedetect -i "$filename" -o processed/ detect-content split-video; done >> redo.sh
              echo "Script created. cat redo.sh"
              cat redo.sh
              chmod +x redo.sh
              mkdir -p processed/ || true
              ./redo.sh
          }

          redo_folders(){
              mkdir -p square/{iamprofessorex,wavymemes}
              mkdir -p reels/{iamprofessorex,wavymemes}
              mv -fv *reel-good*wavy* reels/wavymemes
              mv -fv *reel-good*iamprofessor* reels/iamprofessorex
              mv -fv *post-good*iamprofessor* square/iamprofessorex
              mv -fv *post-good*wavymemes* square/wavymemes
          }

          ffmpeg-duration-rm(){
              pyenv activate cv3 || true
              echo '#!/usr/bin/env bash' > duration.sh
              [ "$(ls *.mp4 | tr " " '\r' | wc -l | awk '{print $1}')" -gt "0" ] && for filename in ./*mp4*; do echo "video_duration=\$(ffmpeg-duration -f \"${filename}\") && [ \"5\" -gt \"\$video_duration\" ] && rm -fv ${filename} || echo skipping"; done >> duration.sh
              echo "Script created. cat duration.sh"
              cat duration.sh
              chmod +x duration.sh
          }

          redo_pyscenedetect_all_clean(){
              redo_pyscenedetect_all
              ffmpeg-duration-rm
          }


          daily-story-pull(){
              pyenv activate ffmpeg-tools3 || true
              ffmpeg-tools -c dl-story --user clips || true
              ffmpeg-tools -c dl-story --user maudlowis || true
              ffmpeg-tools -c dl-story --user thouartanuli || true
              ffmpeg-tools -c dl-story --user stargotsole || true
              ffmpeg-tools -c dl-story --user blk.unicorn_cosplay || true
              ffmpeg-tools -c dl-story --user lifeasnikita || true
              ffmpeg-tools -c dl-story --user betches || true
              ffmpeg-tools -c dl-story --user machonutz || true
              # ffmpeg-tools -c dl-story --user kirtfloydtrini || true
              # ffmpeg-tools -c dl-story --user kirillagain || true
              # ffmpeg-tools -c dl-story --user hoe_wives_vibes__ || true
              ffmpeg-tools -c dl-story --user theraunchyfemale2 || true
              ffmpeg-tools -c dl-story --user main_hoe_memes || true
              ffmpeg-tools -c dl-story --user mistress_carnage_cosplay || true
              ffmpeg-tools -c dl-story --user woesenpaixo || true
              ffmpeg-tools -c dl-story --user sjtblood87 || true
              ffmpeg-tools -c dl-story --user datgaljuju777 || true
              ffmpeg-tools -c dl-story --user iamkarynelle || true
              ffmpeg-tools -c dl-story --user mami_ah_fire1 || true
              ffmpeg-tools -c dl-story --user meeeowth_thats_wright  || true
              ffmpeg-tools -c dl-story --user ms.sethii || true
              ffmpeg-tools -c dl-story --user r3sili3nt._ || true
              ffmpeg-tools -c dl-story --user trippledddiaz || true
          }


      - name: youtube.zsh
        content: |
          dl(){
              echo "running dl \"${1}\" ..."
              /usr/local/bin/youtube-dl -o "$(uuidgen).%(ext)s" "${1}"
              echo ""
          }

          dl-best(){
              echo "running dl-best \"${1}\" ..."
              /usr/local/bin/youtube-dl -o "$(uuidgen).%(ext)s" -f $(/usr/local/bin/youtube-dl -o "$(uuidgen).%(ext)s" -F "${1}" | grep best | grep mp4 | head -1 | awk '{print $1}') "${1}"
              echo ""
          }

          dl-mp3(){
              echo "running dl-mp3 \"${1}\" ..."
              /usr/local/bin/youtube-dl --extract-audio --audio-format mp3 "${1}"
              echo ""
          }

          youtube-dl-best-until(){
              until dl-best "${1}" &> /dev/null
              do
                  echo "running dl-best \"${1}\" ..."
                  sleep 1
              done
              echo -e "\nThe mp4 is downloaded."
          }



          youtube-dl-mp3-orig-name-until(){
              until dl-mp3-orig-name "${1}" &> /dev/null
              do
                  echo "running dl-mp3-orig-name \"${1}\" ..."
                  sleep $((1 + $RANDOM % 10))
              done
              echo -e "\nThe mp3 is downloaded."
          }

          # SOURCE: https://github.com/gko/dotfiles/blob/6f63f4a5ffdfbded718bd1eee8723e02ec2a5335/aliases/youtube-dl.sh
          youtube-dl-aliases () {
            local YOUTUBE_DL_OPTIONS="--ignore-errors \
              --restrict-filenames \
              --no-mark-watched \
              --geo-bypass \
              --write-description \
              --write-info-json \
              --write-thumbnail \
              --all-subs \
              --no-mtime \
              --embed-thumbnail \
              --embed-subs \
              --add-metadata"

            # youtube-dl aliases
            alias youtube-dl-best='youtube-dl \
              '"$YOUTUBE_DL_OPTIONS"' \
              --format "bestvideo[ext=mp4]+bestaudio[ext=m4a]/bestvideo+bestaudio" '
            alias youtube-dl-480='youtube-dl \
              '"$YOUTUBE_DL_OPTIONS"' \
              --format "bestvideo[height<=480][ext=mp4]+bestaudio[ext=m4a]" '
            alias youtube-dl-720='youtube-dl \
              '"$YOUTUBE_DL_OPTIONS"' \
              --format "bestvideo[height<=720][ext=mp4]+bestaudio[ext=m4a]" '
            alias youtube-dl-4k='echo -e "This will transcode the video from webm to h264 which could take a long time\n\n"; \
              youtube-dl -f "bestvideo[ext=webm]+bestaudio[ext=m4a]" \
              '"$YOUTUBE_DL_OPTIONS"' \
              --recode-video mp4 '
            alias youtube-dl-playlist='youtube-dl \
              '"$YOUTUBE_DL_OPTIONS"' \
              --download-archive archive.txt \
              --output "./%(playlist_title)s/%(playlist_index)s_%(title)s.%(ext)s" '
            alias youtube-dl-mp3='youtube-dl --extract-audio \
              '"$YOUTUBE_DL_OPTIONS"' \
              --format bestaudio \
              --download-archive archive.txt \
              --audio-format mp3 \
              --no-playlist '
            alias youtube-dl-mp3-playlist='youtube-dl --ignore-errors \
              '"$YOUTUBE_DL_OPTIONS"' \
              --format bestaudio \
              --extract-audio \
              --audio-format mp3 \
              --audio-quality 160K \
              --output "./%(playlist_title)s/%(playlist_index)s_%(title)s.%(ext)s" \
              --yes-playlist '
          }

          yt-dl-thumb () {
            echo " [running] youtube-dl -v -f best -n --ignore-errors --restrict-filenames --write-thumbnail --no-mtime --embed-thumbnail --recode-video mp4 --cookies=~/Downloads/yt-cookies.txt ${1}"
            youtube-dl -v -f best -n --ignore-errors --restrict-filenames --write-thumbnail --no-mtime --embed-thumbnail --recode-video mp4 --cookies=~/Downloads/yt-cookies.txt ${1}
          }

          alias dl-thumb='yt-dl-thumb'

          yt-dl-best-test () {
            echo " [running] youtube-dl -v -f \"bestvideo[ext=mp4]+bestaudio[ext=m4a]/bestvideo+bestaudio\" -n --ignore-errors --restrict-filenames --write-thumbnail --no-mtime --embed-thumbnail --recode-video mp4 --cookies=~/Downloads/yt-cookies.txt ${1}"
            youtube-dl -v -f "bestvideo[ext=mp4]+bestaudio[ext=m4a]/bestvideo+bestaudio" -n --ignore-errors --restrict-filenames --write-thumbnail --no-mtime --embed-thumbnail --recode-video mp4 --cookies=~/Downloads/yt-cookies.txt ${1}
          }

          yt-best () {
            echo " [running] youtube-dl -v -f \"bestvideo[ext=mp4]+bestaudio[ext=m4a]/bestvideo+bestaudio\" -n --ignore-errors --restrict-filenames --write-thumbnail --no-mtime --embed-thumbnail --recode-video mp4 --cookies=~/Downloads/yt-cookies.txt --write-info-json ${1}"
            youtube-dl -v -f "bestvideo[ext=mp4]+bestaudio[ext=m4a]/bestvideo+bestaudio" -n --ignore-errors --restrict-filenames --write-thumbnail --no-mtime --embed-thumbnail --recode-video mp4 --cookies=~/Downloads/yt-cookies.txt --write-info-json ${1}
          }

          dl-split () {
            while IFS="" read -r p || [ -n "$p" ]; do
              yt-best $p
            done < download.txt
          }

          dl-safe () {
            pyenv activate ffmpeg-tools3 || true
            local url=${1}

            dl-thumb ${url}

            _RETVAL=$?

            if [[ "${_RETVAL}" != "0" ]]; then
                echo "Trying yt-best instead"
                yt-best ${url}

                _RETVAL=$?

                if [[ "${_RETVAL}" != "0" ]]; then
                    echo "Trying youtube-dl instead"
                    youtube-dl ${url}
                fi
            fi


          }

          prepare_from_square() {
            pyenv activate ffmpeg-tools3 || true
            ffmpeg-tools -c prepare-from-square -f "$(PWD)" -r
            find . -name "white.jpg" -exec rm -rfv {} \;
          }



      - name: unixorn.zsh
        content: |
          # SOURCE: https://github.com/unixorn/zsh-quickstart-kit/blob/master/zsh/.zsh_aliases
          # aliases borrowed from unixorn
          alias historysummary="history | awk '{a[\$2]++} END{for(i in a){printf \"%5d\t%s\n\",a[i],i}}' | sort -rn | head"

          # A couple of different external IP lookups depending on which is down.
          alias external_ip="curl -s icanhazip.com"
          alias myip="dig +short myip.opendns.com @resolver1.opendns.com"

          # Show laptop's IP addresses
          alias ips="ifconfig -a | perl -nle'/(\d+\.\d+\.\d+\.\d+)/ && print $1'"

          # SSH stuff
          # Pass our credentials by default
          alias sshA='ssh -A'
          alias ssh-A='ssh -A'
          alias ssh-unkeyed='/usr/bin/ssh'
          alias ssh_unkeyed='/usr/bin/ssh'

          alias scp-no-hostchecks='scp -o UserKnownHostsFile=/dev/null -o GlobalKnownHostsFile=/dev/null -o StrictHostKeyChecking=no'
          alias ssh-no-hostchecks='ssh -A -o UserKnownHostsFile=/dev/null -o GlobalKnownHostsFile=/dev/null -o StrictHostKeyChecking=no'
          alias scp_no_hostchecks='scp -o UserKnownHostsFile=/dev/null -o GlobalKnownHostsFile=/dev/null -o StrictHostKeyChecking=no'
          alias ssh_no_hostchecks='ssh -A -o UserKnownHostsFile=/dev/null -o GlobalKnownHostsFile=/dev/null -o StrictHostKeyChecking=no'

          # Set up even more shortcuts because I am that lazy a typist.
          alias nh-scp=scp-no-hostchecks
          alias nh-ssh=ssh-no-hostchecks
          alias nh_scp=scp-no-hostchecks
          alias nh_ssh=ssh-no-hostchecks
          alias nhscp=scp-no-hostchecks
          alias nhssh=ssh-no-hostchecks

          # Strip color codes from commands that insist on spewing them so we can
          # pipe them into files cleanly.
          alias stripcolors='sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[mGK]//g"'

          # lists zombie processes
          zombie() {
            ps aux | awk '{if ($8=="Z") { print $2 }}'
          }
          alias zombies=zombie


    bossjones__oh__my__zsh__bin_files:
      - name: imagemagick_resize_square
        content: |
          #!/usr/bin/env bash
          _input=$(basename -- "${1}" | cut -d"." -f1)
          get_extension=$(basename -- $1 | cut -d"." -f2)
          _input_fname="${_input}.${get_extension}"
          _out_fname="${_input}_out.${get_extension}"
          _background="white.jpg"
          _overlay=${_input_fname}

          echo "_input = $_input"
          echo "get_extension = $get_extension"
          echo "_input_fname = $_input_fname"
          echo "_out_fname = $_out_fname"

          # https://legacy.imagemagick.org/Usage/compose/
          # https://legacy.imagemagick.org/Usage/compose/#over
          # Note that the order of the images is very important as you get very different results if the images, or the operator are swapped. This is especially the case with the "convert" command, which has the destination image before the source image.
          # The following commands are the two direct image 'composite' methods available in ImageMagick...

          # composite {overlay} {background} [{mask}] [-compose {method}]   {result}
          # convert  {background} {overlay} [{mask}] [-compose {method}] -composite   {result}

          # The "composite" command is the conventional method of compositing in IM. Having a dedicated command demonstrates just how important Image Composition is.

          # The "convert" operator "-composite" can also do Image Composition as part of a larger image processing task. Note the reversed order of the images when using "convert". The order is practical as you are generally working with a primary canvas over which you prepare and merge images forming a new image. The order of the images is important.

          # Practical examples of both techniques (and more) can be reviewed in Layers of Multiple Images, and is recomended reading before continuing.

          # convert -verbose "${_background}" "${_overlay}" -set colorspace RGB -resize 1080x1080 -gravity center -compose Copy_Black -interlace JPEG -composite "${_out_fname}"
          # convert -verbose "${_background}" "${_overlay}" -set colorspace RGB -resize 1080x1080 -gravity center -compose blend -define compose:args=100,100 -interlace JPEG -composite "${_out_fname}"
          # convert -verbose "${_background}" "${_overlay}" -set colorspace RGB -resize 1080x1080 -gravity center -compose Src -alpha set -interlace JPEG -composite "${_out_fname}"

          # convert -verbose "${_background}" "${_overlay}" -set colorspace RGB -resize 1080x1080 -gravity center -interlace JPEG -composite "${_out_fname}"


          # magick 151325673_1017500572117138_6338645722784183762_n.jpg -resize 1080x1080 -background white -compose Copy \
          # -gravity center -extent 1080x1080 -quality 92 output.jpg

          # -compose blend \
          # -define compose:args={src_percent},{dst_percent}

          magick "${_overlay}" -resize 1080x1080 -background white -compose Copy -gravity center -extent 1080x1080 -quality 92 "${_out_fname}"


    bossjones__oh__my__zsh__zshrc_local: |-
      export SHELL="{{bossjones__oh__my__zsh__path_to_shell}}"
      # export RBENV_ROOT=~/.rbenv
      export RBENV_VERSION={{rbenv.default_ruby}}
      export VIRTUAL_ENV_DISABLE_PROMPT=1
      export ZSH_PYENV_LAZY_VIRTUALENV=1

      # set some history options
      setopt append_history
      setopt extended_history
      setopt hist_expire_dups_first
      setopt hist_ignore_all_dups
      setopt hist_ignore_dups
      setopt hist_ignore_space
      setopt hist_reduce_blanks
      setopt hist_save_no_dups
      setopt hist_verify
      setopt INC_APPEND_HISTORY
      unsetopt HIST_BEEP

      # Share your history across all your terminal windows
      setopt share_history
      #setopt noclobber

      # Larger bash history (allow 32Â³ entries; default is 500)

      HISTSIZE=100000
      SAVEHIST=100000
      HISTFILE="$HOME/.zsh_history"
      # export HISTCONTROL=ignoredups

      # # Prefer US English and use UTF-8
      # export LANG=en_US.UTF-8
      # export LC_ALL=en_US.UTF-8

      # # SOURCE: https://github.com/luismayta/dotfiles/blob/597ddc09e1bfccc43076ca21cb679299b83912e4/conf/shell/zshrc
      # # don't put duplicate lines in the history. See bash(1) for more options
      # # ... or force ignoredups and ignorespace
      # HISTCONTROL=ignoredups:ignorespace

      # # for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
      # HISTSIZE=100000
      # HISTFILESIZE=2000

      alias reload!='exec "$SHELL" -l'

      fixprompt() {
        antigen reset; reload!
      }

      # setopt HIST_FIND_NO_DUPS

      # Add some completions settings
      setopt ALWAYS_TO_END     # Move cursor to the end of a completed word.
      setopt AUTO_LIST         # Automatically list choices on ambiguous completion.
      setopt AUTO_MENU         # Show completion menu on a successive tab press.
      setopt AUTO_PARAM_SLASH  # If completed parameter is a directory, add a trailing slash.
      setopt COMPLETE_IN_WORD  # Complete from both ends of a word.
      unsetopt MENU_COMPLETE   # Do not autoselect the first completion entry.

      # Long running processes should return time after they complete. Specified
      # in seconds.
      REPORTTIME=2
      TIMEFMT="%U user %S system %P cpu %*Es total"

      # # Speed up autocomplete, force prefix mapping
      # zstyle ':completion:*' accept-exact '*(N)'
      # zstyle ':completion:*' use-cache on
      # zstyle ':completion:*' cache-path ~/.zsh/cache
      # zstyle -e ':completion:*:default' list-colors 'reply=("${PREFIX:+=(#bi)($PREFIX:t)*==34=34}:${(s.:.)LS_COLORS}")';


      if [[ -n "$(command which direnv)" ]]; then
          eval "$(direnv hook zsh)"
      fi

      # [ -f ~/.fzf.zsh ] && source ~/.fzf.zsh
      test -f "$HOME/.fzf.zsh" && . "$HOME/.fzf.zsh"


      # remove dupes from $PATH using a zsh builtin
      # https://til.hashrocket.com/posts/7evpdebn7g-remove-duplicates-in-zsh-path
      # typeset -aU path;

      # SOURCE: https://github.com/mcornella/dotfiles/blob/main/zshenv
      # remove duplicate entries from PATH
      [ -n "$ZSH_VERSION" ] && {
        typeset -U path
        fpath+=("$HOME/.zsh/completions")
      }

      # export PATH for other sessions
      export PATH
      # SOURCE: https://github.com/mcornella/dotfiles/blob/main/zshenv - end

      # # Load iTerm shell integrations if found.
      # test -e "${HOME}/.iterm2_shell_integration.zsh" && source "${HOME}/.iterm2_shell_integration.zsh"

      # Expand aliases inline - see http://blog.patshead.com/2012/11/automatically-expaning-zsh-global-aliases---simplified.html
      globalias() {
        if [[ $LBUFFER =~ ' [A-Z0-9]+$' ]]; then
          zle _expand_alias
          zle expand-word
        fi
        zle self-insert
      }

      zle -N globalias

      bindkey " " globalias
      bindkey "^ " magic-space           # control-space to bypass completion
      bindkey -M isearch " " magic-space # normal space during searches


  roles:
    - ../ansible-role-oh-my-zsh

  pre_tasks:

    - name: ensure directories exist
      file:
        dest: "~/{{ item }}"
        state: directory
        mode: 0700
      loop:
        - .bin
        - bin
        - .local/bin
        - .oh-my-zsh/custom/plugins
        - .zsh/completion
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"

    # SOURCE: https://github.com/veggiemonk/ansible-dotfiles/blob/master/tasks/fonts.yml
    - name: 'Cloning fonts | based on https://gist.github.com/ganapativs/e571d9287cb74121d41bfe75a0c864d7'
      git:
        repo=https://github.com/powerline/fonts
        dest="~/powerlinefonts"
        accept_hostkey=yes
        depth=1
      register: fontCloned
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"
      when: not (bossjones__oh__my__zsh__user == 'root' and ansible_os_family == 'Darwin')

    - name: 'Cloning goenv | based on https://github.com/syndbg/goenv/blob/master/INSTALL.md'
      git:
        repo=https://github.com/syndbg/goenv
        dest="~/.goenv"
        accept_hostkey=yes
      register: goenvCloned
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"
      when: not (bossjones__oh__my__zsh__user == 'root' and ansible_os_family == 'Darwin')

    - name: 'Cloning iterm2-snazzy theme, dont forget to double click ~/iterm2-snazzy/Snazzy.itermcolors'
      git:
        repo=https://github.com/sindresorhus/iterm2-snazzy
        dest="~/iterm2-snazzy"
        accept_hostkey=yes
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"
      when: not (bossjones__oh__my__zsh__user == 'root' and ansible_os_family == 'Darwin')

    - name: Install Fonts
      shell: ~/powerlinefonts/install.sh chdir=~/powerlinefonts
      # when: fontCloned is success
      check_mode: no
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"
      ignore_errors: yes
      changed_when: false
      failed_when: false
      when: (fontCloned is success) and not (bossjones__oh__my__zsh__user == 'root' and ansible_os_family == 'Darwin')

    - name: 'brew tap homebrew/cask-fonts'
      homebrew_tap:
        name: homebrew/cask-fonts
        state: present
      # brew don't work from root user on macOS
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"
      when: not (bossjones__oh__my__zsh__user == 'root' and ansible_os_family == 'Darwin')

    - name: Install font-fira-code
      homebrew_cask:
        name: "{{ item }}"
        state: present
      with_items:
        - font-fira-code
        - font-fira-code-nerd-font
        - font-hack-nerd-font
        - font-inconsolata-nerd-font
        - font-meslo-lg-nerd-font
        - font-sauce-code-pro-nerd-font
      # brew don't work from root user on macOS
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"
      when: not (bossjones__oh__my__zsh__user == 'root' and ansible_os_family == 'Darwin')

    - name: Install/Setup asdf and direnv
      package:
        name: '{{ item }}'
        state: latest
      with_items:
        - asdf
        - atomicparsley
        - cmake
        - coreutils
        - direnv
        - doxygen
        - eigen
        - ffmpeg
        - findutils
        - fpp
        - fzf
        - gawk
        - gnu-getopt
        - gnu-indent
        - gnu-sed
        - gnu-tar
        - gnutls
        - graphicsmagick
        - grep
        - hdf5
        - icu4c
        - imagemagick
        - jpeg
        - jq
        - lesspipe
        - libav
        - libffi
        - libmagic
        - libomp
        - libpng
        - libtiff
        - libxslt
        - moreutils
        - nmap
        - openblas
        - openexr
        - openmpi
        - openssl
        - peco
        - unzip
        - asdf
        - perl
        - pkg-config
        - pyenv
        - pyenv-virtualenv
        - pyenv-virtualenvwrapper
        - rbenv
        - readline
        - reattach-to-user-namespace
        - sdl2
        - sdl2_mixer
        - sqlite3
        - tbb
        - tcl-tk
        - tesseract
        - the_silver_searcher
        - tmux
        - tree
        - urlview
        - vim
        - wget
        - xz
        - zlib
        - zsh
        # - python@3.8
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"
      when: not (bossjones__oh__my__zsh__user == 'root' and ansible_os_family == 'Darwin')


    - name: Clone unixorn git-extra-commands
      git:
        repo: https://github.com/unixorn/git-extra-commands.git
        dest: "~/.oh-my-zsh/custom/plugins/git-extra-commands"
        version: "main"
        force: yes
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"
      register: bossjones__oh__my__zsh__register_git_extra_commands

      # mkdir -p "$HOME/.zsh"
      # git clone https://github.com/sindresorhus/pure.git "$HOME/.zsh/pure"
    - name: Clone pure
      git:
        repo: https://github.com/sindresorhus/pure.git
        dest: "~/.zsh/pure"
        version: "main"
        force: yes
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"
      register: bossjones__oh__my__zsh__register_pure

    - name: Clone zsh-peco-history
      git:
        repo: https://github.com/jimeh/zsh-peco-history.git
        dest: "~/.oh-my-zsh/custom/plugins/zsh-peco-history"
        version: "master"
        force: yes
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"
      register: bossjones__oh__my__zsh__register_zsh_peco_history

    - name: Clone chrissicool zsh-256color
      git:
        repo: https://github.com/chrissicool/zsh-256color.git
        dest: "~/.oh-my-zsh/custom/plugins/zsh-256color"
        version: "master"
        force: yes
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"
      register: bossjones__oh__my__zsh__register_zsh_256color

    # git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting
    - name: Clone zsh-users zsh-syntax-highlighting
      git:
        repo: https://github.com/zsh-users/zsh-syntax-highlighting.git
        dest: "~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting"
        version: "master"
        force: yes
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"
      register: bossjones__oh__my__zsh__register_zsh_syntax_highlighting

      # git clone https://github.com/popstas/zsh-command-time.git ~/.oh-my-zsh/custom/plugins/command-time
    # git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting
    - name: Clone zsh-users zsh-command-time
      git:
        repo: https://github.com/popstas/zsh-command-time.git
        dest: "~/.oh-my-zsh/custom/plugins/zsh-command-time"
        version: "master"
        force: yes
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"
      register: bossjones__oh__my__zsh__register_zsh_command_time

    # - name: Clone asdf
    #   git:
    #     repo: https://github.com/asdf-vm/asdf.git
    #     dest: "~/.asdf"
    #     version: "{{ ASDF_VERSION }}"
    #     force: yes
    #   become: yes
    #   become_user: "{{ bossjones__oh__my__zsh__user }}"
    #   register: bossjones__oh__my__zsh__register_asdf

    - name: Clone fzf
      git:
        repo: https://github.com/junegunn/fzf.git
        dest: "~/.fzf"
        version: "{{ FZF_VERSION }}"
        force: yes
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"
      register: bossjones__oh__my__zsh__register_fzf

    - name: Install fzf
      shell: ./install --all
      check_mode: no
      args:
        chdir: "~/.fzf"
      ignore_errors: yes
      changed_when: false
      failed_when: false
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"

    - name: fzf-drafts | download
      shell: |
        curl -L 'https://raw.githubusercontent.com/jan-warchol/dotfiles/master/bin/fzf-drafts' > ~/bin/fzf-drafts;
        chmod +x ~/bin/fzf-drafts;
      args:
        executable: /bin/zsh
      ignore_errors: yes
      changed_when: false
      failed_when: false
      check_mode: no
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"


    - name: compaudit | figure out if anything to fix
      shell: |
        compaudit | wc -l
      args:
        executable: "{{ bossjones__oh__my__zsh__path_to_shell }}"
      register: compaudit_word_count
      # changed_when: false
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"
      ignore_errors: yes
      changed_when: false
      failed_when: false
      check_mode: no

    - name: compaudit | fix
      shell: |
          compaudit | xargs chmod g-w,o-w
          compaudit | xargs chown "{{ bossjones__oh__my__zsh__user }}"
          rm ~/.zcompdump*
      args:
        executable: "{{ bossjones__oh__my__zsh__path_to_shell }}"
      ignore_errors: yes
      changed_when: false
      failed_when: false
      check_mode: no
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"
      when: (compaudit_word_count|bool) and compaudit_word_count.stdout not "0"

    - name: ARM ensure directories are owned correctly for zsh completion to work
      file:
        dest: "{{ item }}"
        state: directory
        owner: "{{ bossjones__oh__my__zsh__user }}"
        group: "{{ bossjones__oh__my__zsh__group }}"
        recurse: yes
      loop:
        - /opt/homebrew/share/zsh/site-functions
        - /opt/homebrew/share/zsh
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"
      when: ansible_facts['os_family'] == 'Darwin' and "arm" in ansible_architecture

    - name: AMD ensure directories are owned correctly for zsh completion to work
      file:
        dest: "{{ item }}"
        state: directory
        owner: "{{ bossjones__oh__my__zsh__user }}"
        group: "{{ bossjones__oh__my__zsh__group }}"
        recurse: yes
      loop:
        - /usr/local/share/zsh/site-functions
        - /usr/local/share/zsh
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"
      when: ansible_facts['os_family'] == 'Darwin' and "amd" in ansible_architecture

    - name: "ensure ~{{ bossjones__oh__my__zsh__user }}/bin/ exists"
      file:
        dest: "{{ item }}"
        state: directory
        owner: "{{ bossjones__oh__my__zsh__user }}"
        group: "{{ bossjones__oh__my__zsh__group }}"
        recurse: yes
      loop:
        - "~{{ bossjones__oh__my__zsh__user }}/bin/"
      become: yes
      become_user: "{{ bossjones__oh__my__zsh__user }}"
      when: ansible_facts['os_family'] == 'Darwin'

    - name: "create ~{{ bossjones__oh__my__zsh__user }}/bin/{{item.name}}"
      copy:
        content: "{{item.content}}"
        dest: "~{{ bossjones__oh__my__zsh__user }}/bin/{{item.name}}"
        owner: "{{ bossjones__oh__my__zsh__user }}"
        group: "{{ bossjones__oh__my__zsh__group }}"
        mode: 0755
      with_items: "{{bossjones__oh__my__zsh__bin_files}}"
